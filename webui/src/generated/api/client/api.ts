/* tslint:disable */
/* eslint-disable */
/**
 * Backend API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface AddFeatureTagRequest {
    /**
     * ID of tag to associate with feature
     */
    'tag_id': string;
}
export interface AddProjectRequest {
    'name': string;
    'description': string;
}
export interface ApprovePendingChangeRequest {
    'approver_user_id': number;
    'approver_name': string;
    'auth': AuthCredentials;
}
/**
 * Type of action performed on entity
 */

export const AuditAction = {
    Create: 'create',
    Update: 'update',
    Delete: 'delete'
} as const;

export type AuditAction = typeof AuditAction[keyof typeof AuditAction];


export interface AuthCredentials {
    'method': AuthCredentialsMethodEnum;
    'credential': string;
    /**
     * Session ID for TOTP approval (required when method is \'totp\')
     */
    'session_id'?: string;
}

export const AuthCredentialsMethodEnum = {
    Password: 'password',
    Totp: 'totp'
} as const;

export type AuthCredentialsMethodEnum = typeof AuthCredentialsMethodEnum[keyof typeof AuthCredentialsMethodEnum];

export interface CancelPendingChangeRequest {
    'cancelled_by': string;
}
export interface Category {
    'id': string;
    'name': string;
    'slug': string;
    'description'?: string;
    'color'?: string;
    'kind': CategoryKindEnum;
    'created_at': string;
    'updated_at': string;
}

export const CategoryKindEnum = {
    System: 'system',
    User: 'user',
    Domain: 'domain'
} as const;

export type CategoryKindEnum = typeof CategoryKindEnum[keyof typeof CategoryKindEnum];

export interface CategoryResponse {
    'category': Category;
}
export interface Change {
    /**
     * Audit log entry ID
     */
    'id': number;
    'entity': EntityType;
    /**
     * ID of the changed entity
     */
    'entity_id': string;
    'action': AuditAction;
    /**
     * Previous value of the entity (null for create actions)
     */
    'old_value': object;
    /**
     * New value of the entity (null for delete actions)
     */
    'new_value': object;
}


export interface ChangeGroup {
    /**
     * Request ID that groups related changes
     */
    'request_id': string;
    /**
     * Who made the changes (system, sdk, user:<user_id>)
     */
    'actor': string;
    /**
     * Username of the user who made the changes
     */
    'username': string;
    /**
     * When the changes were made
     */
    'created_at': string;
    /**
     * List of changes made in this request
     */
    'changes': Array<Change>;
}
export interface ChangeUserPasswordRequest {
    'old_password': string;
    'new_password': string;
}
export interface ChangeValue {
    'old': any;
    'new': any;
}
export interface CreateCategoryRequest {
    'name': string;
    'slug': string;
    'description'?: string;
    'color'?: string;
    'kind': CreateCategoryRequestKindEnum;
}

export const CreateCategoryRequestKindEnum = {
    User: 'user',
    Domain: 'domain'
} as const;

export type CreateCategoryRequestKindEnum = typeof CreateCategoryRequestKindEnum[keyof typeof CreateCategoryRequestKindEnum];

export interface CreateEnvironmentRequest {
    /**
     * Environment key (dev, stage, prod)
     */
    'key': string;
    /**
     * Human-readable environment name
     */
    'name': string;
}
export interface CreateFeatureRequest {
    'key': string;
    'name': string;
    'description'?: string;
    'kind': FeatureKind;
    /**
     * Environment key (dev, stage, prod) for this feature
     */
    'environment_key': string;
    /**
     * Default value for the feature in the specified environment
     */
    'default_value': string;
    /**
     * Whether the feature is enabled in the specified environment
     */
    'enabled': boolean;
    'rollout_key'?: string;
    /**
     * Optional list of flag variants to create along with the feature
     */
    'variants'?: Array<CreateFlagVariantInline>;
    /**
     * Optional list of rules to create along with the feature
     */
    'rules'?: Array<CreateRuleInline>;
}


export interface CreateFeatureScheduleRequest {
    'starts_at'?: string;
    'ends_at'?: string;
    'cron_expr'?: string;
    /**
     * Duration for cron-based schedules. When cron triggers, feature will be enabled/disabled for this duration. Format: \'1h30m\', \'45m\', \'2h\', etc.
     */
    'cron_duration'?: string;
    'timezone': string;
    'action': FeatureScheduleAction;
}


export interface CreateFlagVariantInline {
    /**
     * Client-provided UUID for the variant
     */
    'id': string;
    'name': string;
    'rollout_percent': number;
    /**
     * Environment key (dev, stage, prod) for this variant
     */
    'environment_key': string;
}
export interface CreateFlagVariantRequest {
    'name': string;
    'rollout_percent': number;
}
export interface CreateProjectSettingRequest {
    'name': string;
    'value': object;
}
export interface CreateProjectTagRequest {
    'name': string;
    'slug': string;
    'description'?: string;
    'color'?: string;
    /**
     * ID of category to associate with this tag
     */
    'category_id'?: string;
}
export interface CreateRuleAttributeRequest {
    'name': string;
    'description'?: string;
}
export interface CreateRuleInline {
    /**
     * Client-provided UUID for the rule
     */
    'id': string;
    'conditions': RuleConditionExpression;
    'segment_id'?: string;
    'is_customized': boolean;
    'action': RuleAction;
    'flag_variant_id'?: string;
    'priority'?: number;
    /**
     * Environment key (dev, stage, prod) for this rule
     */
    'environment_key': string;
}


export interface CreateRuleRequest {
    'conditions': RuleConditionExpression;
    'segment_id'?: string;
    'is_customized': boolean;
    'action': RuleAction;
    'flag_variant_id'?: string;
    'priority'?: number;
}


export interface CreateSegmentRequest {
    'name': string;
    'description'?: string;
    'conditions': RuleConditionExpression;
}
export interface CreateUserRequest {
    'username': string;
    'email': string;
    'password': string;
    'is_superuser'?: boolean;
}
export interface CreateUserResponse {
    'user': User;
}
export interface EntityChange {
    'entity': EntityChangeEntityEnum;
    'entity_id': string;
    'action': EntityChangeActionEnum;
    'changes': { [key: string]: ChangeValue; };
}

export const EntityChangeEntityEnum = {
    Feature: 'feature',
    Rule: 'rule',
    FeatureSchedule: 'feature_schedule'
} as const;

export type EntityChangeEntityEnum = typeof EntityChangeEntityEnum[keyof typeof EntityChangeEntityEnum];
export const EntityChangeActionEnum = {
    Insert: 'insert',
    Update: 'update',
    Delete: 'delete'
} as const;

export type EntityChangeActionEnum = typeof EntityChangeActionEnum[keyof typeof EntityChangeActionEnum];

/**
 * Type of entity that was changed
 */

export const EntityType = {
    Feature: 'feature',
    Rule: 'rule',
    FlagVariant: 'flag_variant',
    FeatureSchedule: 'feature_schedule'
} as const;

export type EntityType = typeof EntityType[keyof typeof EntityType];


export interface Environment {
    /**
     * Environment ID
     */
    'id': number;
    /**
     * Project ID
     */
    'project_id': string;
    /**
     * Environment key (dev, stage, prod)
     */
    'key': string;
    /**
     * Human-readable environment name
     */
    'name': string;
    /**
     * API key for this environment
     */
    'api_key': string;
    /**
     * Creation timestamp
     */
    'created_at': string;
}
export interface EnvironmentResponse {
    'environment'?: Environment;
}
export interface Error2FARequired {
    'error': Error2FARequiredError;
}
export interface Error2FARequiredError {
    'code': string;
    'session_id': string;
    'message': string;
}
export interface ErrorBadRequest {
    'error': ErrorError;
}
export interface ErrorConflict {
    'error': ErrorConflictError;
}
export interface ErrorConflictError {
    'message'?: string;
    'code'?: string;
}
export interface ErrorError {
    'message'?: string;
}
export interface ErrorInternalServerError {
    'error': ErrorError;
}
export interface ErrorInvalidCredentials {
    'error': ErrorError;
}
export interface ErrorInvalidToken {
    'error': ErrorError;
}
export interface ErrorNotFound {
    'error': ErrorError;
}
export interface ErrorPermissionDenied {
    'error': ErrorError;
}
export interface ErrorTooManyRequests {
    'error': ErrorError;
}
export interface ErrorUnauthorized {
    'error': ErrorError;
}
export interface Feature {
    'id': string;
    'project_id': string;
    'key': string;
    'name': string;
    'description'?: string;
    'kind': FeatureKind;
    'rollout_key'?: string;
    /**
     * Whether the feature is enabled in the specified environment
     */
    'enabled': boolean;
    /**
     * Default value for the feature in the specified environment
     */
    'default_value': string;
    'created_at': string;
    'updated_at': string;
}


export interface FeatureDetailsResponse {
    'feature': FeatureExtended;
    'variants': Array<FlagVariant>;
    'rules': Array<Rule>;
    'tags': Array<ProjectTag>;
}
export interface FeatureExtended {
    'id': string;
    'project_id': string;
    'key': string;
    'name': string;
    'description'?: string;
    'kind': FeatureKind;
    'rollout_key'?: string;
    /**
     * Whether the feature is enabled in the specified environment
     */
    'enabled': boolean;
    /**
     * Default value for the feature in the specified environment
     */
    'default_value': string;
    'created_at': string;
    'updated_at': string;
    /**
     * Indicates if the feature is currently active (taking schedules)
     */
    'is_active': boolean;
    /**
     * Indicates the next state the feature will transition to based on schedule (null if no schedule)
     */
    'next_state'?: boolean;
    /**
     * Timestamp when the feature will transition to the next state (null if no schedule)
     */
    'next_state_time'?: string;
    /**
     * Tags associated with this feature
     */
    'tags'?: Array<ProjectTag>;
}



export const FeatureKind = {
    Simple: 'simple',
    Multivariant: 'multivariant'
} as const;

export type FeatureKind = typeof FeatureKind[keyof typeof FeatureKind];


export interface FeatureResponse {
    'feature': Feature;
}
export interface FeatureSchedule {
    'id': string;
    'project_id': string;
    'feature_id': string;
    'starts_at'?: string;
    'ends_at'?: string;
    'cron_expr'?: string;
    /**
     * Duration for cron-based schedules. When cron triggers, feature will be enabled/disabled for this duration. Format: \'1h30m\', \'45m\', \'2h\', etc.
     */
    'cron_duration'?: string;
    'timezone': string;
    'action': FeatureScheduleAction;
    'created_at': string;
}


/**
 * Action to apply on schedule
 */

export const FeatureScheduleAction = {
    Enable: 'enable',
    Disable: 'disable'
} as const;

export type FeatureScheduleAction = typeof FeatureScheduleAction[keyof typeof FeatureScheduleAction];


export interface FeatureScheduleResponse {
    'schedule': FeatureSchedule;
}
export interface FeatureTimelineEvent {
    'time': string;
    'enabled': boolean;
}
export interface FeatureTimelineResponse {
    'events': Array<FeatureTimelineEvent>;
}
export interface FlagVariant {
    'id': string;
    'feature_id': string;
    'name': string;
    'rollout_percent': number;
}
export interface FlagVariantResponse {
    'flag_variant': FlagVariant;
}
export interface ForgotPasswordRequest {
    'email': string;
}
export interface InitiateTOTPApprovalRequest {
    'approver_user_id': number;
}
export interface InitiateTOTPApprovalResponse {
    /**
     * Session ID to use for TOTP approval
     */
    'session_id': string;
    'message': string;
}
export interface LDAPConfig {
    /**
     * Whether LDAP integration is enabled
     */
    'enabled': boolean;
    /**
     * LDAP server URL
     */
    'url': string;
    /**
     * DN for binding to LDAP server
     */
    'bind_dn': string;
    /**
     * Password for binding to LDAP server
     */
    'bind_password': string;
    /**
     * Base DN for user search
     */
    'user_base_dn': string;
    /**
     * Filter for user search
     */
    'user_filter': string;
    /**
     * Attribute for username
     */
    'user_name_attr': string;
    /**
     * Attribute for user email
     */
    'user_email_attr': string;
    /**
     * Whether to use StartTLS
     */
    'start_tls': boolean;
    /**
     * Whether to skip TLS certificate verification
     */
    'insecure_tls': boolean;
    /**
     * Connection timeout
     */
    'timeout': string;
    /**
     * Background synchronization interval
     */
    'sync_interval': number;
}
export interface LDAPConfigResponse {
    'message'?: string;
    'config'?: LDAPConfig;
}
export interface LDAPConnectionTest {
    /**
     * LDAP server URL
     */
    'url': string;
    /**
     * DN for binding to LDAP server
     */
    'bind_dn': string;
    /**
     * Password for binding to LDAP server
     */
    'bind_password': string;
    /**
     * Base DN for user search
     */
    'user_base_dn'?: string;
    /**
     * Filter for user search
     */
    'user_filter'?: string;
    /**
     * Attribute for username
     */
    'user_name_attr'?: string;
    /**
     * Whether to use StartTLS
     */
    'start_tls'?: boolean;
    /**
     * Whether to skip TLS certificate verification
     */
    'insecure_tls'?: boolean;
    /**
     * Connection timeout
     */
    'timeout'?: string;
}
export interface LDAPConnectionTestResponse {
    'success'?: boolean;
    'message'?: string;
    'details'?: LDAPConnectionTestResponseDetails;
}
export interface LDAPConnectionTestResponseDetails {
    'server_info'?: string;
    'user_count'?: number;
    'test_user'?: string;
}
export interface LDAPStatistics {
    'ldap_users'?: number;
    'local_users'?: number;
    'active_users'?: number;
    'inactive_users'?: number;
    'sync_history'?: Array<LDAPStatisticsSyncHistoryInner>;
    'sync_success_rate'?: number;
}
export interface LDAPStatisticsSyncHistoryInner {
    'date'?: string;
    'users_synced'?: number;
    'errors'?: number;
    'duration_minutes'?: number;
}
export interface LDAPSyncLogDetails {
    'id': number;
    'timestamp': string;
    'level': LDAPSyncLogDetailsLevelEnum;
    'message': string;
    'username'?: string;
    'details'?: string;
    'sync_session_id': string;
    'stack_trace'?: string;
    'ldap_error_code'?: number;
    'ldap_error_message'?: string;
}

export const LDAPSyncLogDetailsLevelEnum = {
    Info: 'info',
    Warning: 'warning',
    Error: 'error'
} as const;

export type LDAPSyncLogDetailsLevelEnum = typeof LDAPSyncLogDetailsLevelEnum[keyof typeof LDAPSyncLogDetailsLevelEnum];

export interface LDAPSyncLogEntry {
    'id': number;
    'timestamp': string;
    'level': LDAPSyncLogEntryLevelEnum;
    'message': string;
    'username'?: string;
    'details'?: string;
    'sync_session_id': string;
}

export const LDAPSyncLogEntryLevelEnum = {
    Info: 'info',
    Warning: 'warning',
    Error: 'error'
} as const;

export type LDAPSyncLogEntryLevelEnum = typeof LDAPSyncLogEntryLevelEnum[keyof typeof LDAPSyncLogEntryLevelEnum];

export interface LDAPSyncLogs {
    'logs'?: Array<LDAPSyncLogEntry>;
    'total'?: number;
    'has_more'?: boolean;
}
export interface LDAPSyncProgress {
    'is_running': boolean;
    'progress': number;
    'current_step': string;
    'processed_items': number;
    'total_items': number;
    'estimated_time': string;
    'start_time': string;
    'sync_id': string;
}
export interface LDAPSyncStartResponse {
    'message'?: string;
    'sync_id'?: string;
    'estimated_duration'?: string;
}
export interface LDAPSyncStatus {
    'status': string;
    'is_running': boolean;
    'last_sync_time'?: string;
    'total_users': number;
    'synced_users': number;
    'errors': number;
    'warnings': number;
    'last_sync_duration'?: string;
}
/**
 * Type of license feature
 */

export const LicenseFeature = {
    Sso: 'sso',
    Ldap: 'ldap',
    CorpNotifChannels: 'corp_notif_channels'
} as const;

export type LicenseFeature = typeof LicenseFeature[keyof typeof LicenseFeature];


export interface LicenseStatusResponse {
    'license': LicenseStatusResponseLicense;
}
export interface LicenseStatusResponseLicense {
    /**
     * License ID
     */
    'id'?: string;
    'type'?: LicenseType;
    /**
     * When the license was issued
     */
    'issued_at'?: string;
    /**
     * When the license expires
     */
    'expires_at'?: string;
    /**
     * Whether the license is currently valid
     */
    'is_valid'?: boolean;
    /**
     * Whether the license has expired
     */
    'is_expired'?: boolean;
    /**
     * Number of days until license expires (negative if expired)
     */
    'days_until_expiry'?: number;
    /**
     * The full license text
     */
    'license_text'?: string;
    /**
     * List of features available in this license
     */
    'features'?: Array<LicenseFeature>;
}


/**
 * Type of license
 */

export const LicenseType = {
    Trial: 'trial',
    TrialSelfSigned: 'trial-self-signed',
    Commercial: 'commercial',
    Individual: 'individual'
} as const;

export type LicenseType = typeof LicenseType[keyof typeof LicenseType];


export interface ListChangesResponse {
    /**
     * Project ID
     */
    'project_id': string;
    /**
     * List of change groups
     */
    'items': Array<ChangeGroup>;
    'pagination': Pagination;
}
export interface ListEnvironmentsResponse {
    'items'?: Array<Environment>;
    'pagination'?: Pagination;
}
export interface ListFeaturesResponse {
    'items': Array<FeatureExtended>;
    'pagination': Pagination;
}
export interface ListProjectSettingsResponse {
    'data'?: Array<ProjectSetting>;
    'pagination'?: Pagination;
}
export interface ListSegmentsResponse {
    'items': Array<Segment>;
    'pagination': Pagination;
}

export const LogicalOperator = {
    And: 'and',
    Or: 'or',
    AndNot: 'and_not'
} as const;

export type LogicalOperator = typeof LogicalOperator[keyof typeof LogicalOperator];


export interface LoginRequest {
    'username': string;
    'password': string;
}
export interface LoginResponse {
    'access_token': string;
    'refresh_token': string;
    'expires_in': number;
    'is_tmp_password': boolean;
}
export interface ModelError {
    'error': ErrorError;
}
export interface Pagination {
    'total': number;
    'page': number;
    'per_page': number;
}
export interface PendingChangeMeta {
    'reason': string;
    'client': string;
    'origin': string;
    /**
     * True if the project has only 1 active user (enables auto-approve)
     */
    'single_user_project'?: boolean;
}
export interface PendingChangePayload {
    'entities': Array<EntityChange>;
    'meta': PendingChangeMeta;
}
export interface PendingChangeResponse {
    'id': string;
    'environment_key': string;
    'project_id': string;
    'requested_by': string;
    'request_user_id'?: number;
    'change': PendingChangePayload;
    'status': PendingChangeResponseStatusEnum;
    'created_at': string;
    'approved_by'?: string;
    'approved_user_id'?: number;
    'approved_at'?: string;
    'rejected_by'?: string;
    'rejected_at'?: string;
    'rejection_reason'?: string;
}

export const PendingChangeResponseStatusEnum = {
    Pending: 'pending',
    Approved: 'approved',
    Rejected: 'rejected',
    Cancelled: 'cancelled'
} as const;

export type PendingChangeResponseStatusEnum = typeof PendingChangeResponseStatusEnum[keyof typeof PendingChangeResponseStatusEnum];

export interface PendingChangesListResponse {
    'data': Array<PendingChangeResponse>;
    'pagination': Pagination;
}
export interface ProductInfoResponse {
    /**
     * Unique client identifier for this installation
     */
    'client_id': string;
    /**
     * When the client ID was created
     */
    'created_at': string;
}
export interface Project {
    'id': string;
    'name': string;
    'description': string;
    'created_at': string;
}
export interface ProjectResponse {
    'project': Project;
}
export interface ProjectSetting {
    'id': number;
    'project_id': string;
    'name': string;
    'value': object;
    'created_at': string;
    'updated_at': string;
}
export interface ProjectSettingResponse {
    'id': number;
    'project_id': string;
    'name': string;
    'value': object;
    'created_at': string;
    'updated_at': string;
}
export interface ProjectTag {
    'id': string;
    'project_id': string;
    'category_id'?: string;
    'name': string;
    'slug': string;
    'description'?: string;
    'color'?: string;
    'created_at': string;
    'updated_at': string;
    /**
     * Category this tag belongs to
     */
    'category'?: Category;
}
export interface ProjectTagResponse {
    'tag': ProjectTag;
}
export interface RefreshTokenRequest {
    'refresh_token': string;
}
export interface RefreshTokenResponse {
    'access_token': string;
    'refresh_token': string;
    'expires_in': number;
}
export interface RejectPendingChangeRequest {
    'rejected_by': string;
    'reason': string;
}
export interface ResetPasswordRequest {
    'token': string;
    'new_password': string;
}
export interface Rule {
    'id': string;
    'feature_id': string;
    'conditions': RuleConditionExpression;
    'segment_id'?: string;
    'is_customized': boolean;
    'action': RuleAction;
    'flag_variant_id'?: string;
    'priority': number;
    'created_at': string;
}


/**
 * Type of rule action
 */

export const RuleAction = {
    Assign: 'assign',
    Include: 'include',
    Exclude: 'exclude'
} as const;

export type RuleAction = typeof RuleAction[keyof typeof RuleAction];


export interface RuleAttributeEntity {
    'name': string;
    'description'?: string;
}
/**
 * Single condition item
 */
export interface RuleCondition {
    /**
     * Attribute to match in the rule condition
     */
    'attribute': string;
    'operator': RuleOperator;
    'value': any;
}


/**
 * Boolean expression tree for conditions
 */
export interface RuleConditionExpression {
    'condition'?: RuleCondition;
    'group'?: RuleConditionGroup;
}
export interface RuleConditionGroup {
    'operator': LogicalOperator;
    'children': Array<RuleConditionExpression>;
}


/**
 * Operator for condition comparison
 */

export const RuleOperator = {
    Eq: 'eq',
    Neq: 'neq',
    In: 'in',
    NotIn: 'not_in',
    Gt: 'gt',
    Gte: 'gte',
    Lt: 'lt',
    Lte: 'lte',
    Regex: 'regex',
    Percentage: 'percentage'
} as const;

export type RuleOperator = typeof RuleOperator[keyof typeof RuleOperator];


export interface RuleResponse {
    'rule': Rule;
}
export interface SSOCallbackRequest {
    /**
     * Name of the SSO provider
     */
    'provider': string;
    /**
     * Response from SSO provider (code for OIDC, SAML response for SAML)
     */
    'response': string;
    /**
     * State parameter for CSRF protection
     */
    'state': string;
}
export interface SSOInitiateResponse {
    /**
     * URL to redirect user for SSO login
     */
    'redirect_url': string;
}
export interface SSOProvider {
    /**
     * Internal name of the provider
     */
    'name': string;
    /**
     * Display name for UI
     */
    'display_name': string;
    /**
     * Type of SSO provider
     */
    'type': SSOProviderTypeEnum;
    /**
     * URL to provider icon
     */
    'icon_url'?: string;
    /**
     * Whether the provider is enabled
     */
    'enabled': boolean;
}

export const SSOProviderTypeEnum = {
    Saml: 'saml'
} as const;

export type SSOProviderTypeEnum = typeof SSOProviderTypeEnum[keyof typeof SSOProviderTypeEnum];

export interface SSOProvidersResponse {
    'providers': Array<SSOProvider>;
}
export interface Segment {
    'id': string;
    'project_id': string;
    'name': string;
    'description'?: string;
    'conditions': RuleConditionExpression;
    'created_at': string;
    'updated_at': string;
}
export interface SegmentResponse {
    'segment': Segment;
}
export interface SetSuperuserStatusRequest {
    'is_superuser': boolean;
}
export interface SetUserActiveStatusRequest {
    'is_active': boolean;
}
/**
 * Sort order (ascending or descending)
 */

export const SortOrder = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type SortOrder = typeof SortOrder[keyof typeof SortOrder];


export interface SuccessResponse {
    'message'?: string;
}
export interface TestFeatureSchedule {
    'starts_at'?: string;
    'ends_at'?: string;
    'cron_expr'?: string;
    'timezone': string;
    'action': TestFeatureScheduleActionEnum;
    'cron_duration'?: string;
}

export const TestFeatureScheduleActionEnum = {
    Enable: 'enable',
    Disable: 'disable'
} as const;

export type TestFeatureScheduleActionEnum = typeof TestFeatureScheduleActionEnum[keyof typeof TestFeatureScheduleActionEnum];

export interface TestFeatureTimelineRequest {
    'schedules': Array<TestFeatureSchedule>;
}
export interface ToggleFeatureRequest {
    'enabled': boolean;
}
export interface TwoFAConfirmRequest {
    'code': string;
}
export interface TwoFADisableRequest {
    'email_code': string;
}
export interface TwoFAResetRequest {
    'email_code': string;
}
export interface TwoFASetupResponse {
    'secret': string;
    'qr_url': string;
    /**
     * Base64 PNG QR image
     */
    'qr_image': string;
}
export interface TwoFAVerifyRequest {
    'code': string;
    'session_id': string;
}
export interface TwoFAVerifyResponse {
    'access_token': string;
    'refresh_token': string;
    'expires_in': number;
}
export interface UpdateCategoryRequest {
    'name': string;
    'slug': string;
    'description'?: string;
    'color'?: string;
}
export interface UpdateEnvironmentRequest {
    /**
     * Human-readable environment name
     */
    'name': string;
}
export interface UpdateFeatureScheduleRequest {
    'starts_at'?: string;
    'ends_at'?: string;
    'cron_expr'?: string;
    /**
     * Duration for cron-based schedules. When cron triggers, feature will be enabled/disabled for this duration. Format: \'1h30m\', \'45m\', \'2h\', etc.
     */
    'cron_duration'?: string;
    'timezone': string;
    'action': FeatureScheduleAction;
}


export interface UpdateLicenseAcceptanceRequest {
    /**
     * Flag indicating whether the user accepts the license agreement
     */
    'accepted': boolean;
}
export interface UpdateLicenseRequest {
    /**
     * The license key text
     */
    'license_text': string;
}
export interface UpdateProjectRequest {
    'name': string;
    'description': string;
}
export interface UpdateProjectSettingRequest {
    'value': object;
}
export interface UpdateProjectTagRequest {
    'name': string;
    'slug': string;
    'description'?: string;
    'color'?: string;
    /**
     * ID of category to associate with this tag
     */
    'category_id'?: string;
}
export interface UpdateSegmentRequest {
    'name': string;
    'description'?: string;
    'conditions': RuleConditionExpression;
}
export interface User {
    'id': number;
    'username': string;
    'email': string;
    'is_superuser': boolean;
    'is_active': boolean;
    'is_external': boolean;
    'is_tmp_password': boolean;
    'two_fa_enabled': boolean;
    /**
     * Flag indicating whether the user has accepted the license agreement
     */
    'license_accepted': boolean;
    'created_at': string;
    'last_login'?: string;
    /**
     * Map of project_id to list of permission keys for that project. Contains only projects where user has membership.
     */
    'project_permissions'?: { [key: string]: Array<string>; };
}

/**
 * DefaultApi - axios parameter creator
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add tag to feature
         * @param {string} featureId 
         * @param {AddFeatureTagRequest} addFeatureTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFeatureTag: async (featureId: string, addFeatureTagRequest: AddFeatureTagRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'featureId' is not null or undefined
            assertParamExists('addFeatureTag', 'featureId', featureId)
            // verify required parameter 'addFeatureTagRequest' is not null or undefined
            assertParamExists('addFeatureTag', 'addFeatureTagRequest', addFeatureTagRequest)
            const localVarPath = `/api/v1/features/{feature_id}/tags`
                .replace(`{${"feature_id"}}`, encodeURIComponent(String(featureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addFeatureTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add new project
         * @param {AddProjectRequest} addProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProject: async (addProjectRequest: AddProjectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addProjectRequest' is not null or undefined
            assertParamExists('addProject', 'addProjectRequest', addProjectRequest)
            const localVarPath = `/api/v1/projects/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addProjectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Approve a pending change
         * @param {string} pendingChangeId 
         * @param {ApprovePendingChangeRequest} approvePendingChangeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approvePendingChange: async (pendingChangeId: string, approvePendingChangeRequest: ApprovePendingChangeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pendingChangeId' is not null or undefined
            assertParamExists('approvePendingChange', 'pendingChangeId', pendingChangeId)
            // verify required parameter 'approvePendingChangeRequest' is not null or undefined
            assertParamExists('approvePendingChange', 'approvePendingChangeRequest', approvePendingChangeRequest)
            const localVarPath = `/api/v1/pending_changes/{pending_change_id}/approve`
                .replace(`{${"pending_change_id"}}`, encodeURIComponent(String(pendingChangeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(approvePendingChangeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Archive a project
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveProject: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('archiveProject', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{project_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancel ongoing synchronization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelLDAPSync: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/ldap/sync/cancel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancel a pending change
         * @param {string} pendingChangeId 
         * @param {CancelPendingChangeRequest} cancelPendingChangeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPendingChange: async (pendingChangeId: string, cancelPendingChangeRequest: CancelPendingChangeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pendingChangeId' is not null or undefined
            assertParamExists('cancelPendingChange', 'pendingChangeId', pendingChangeId)
            // verify required parameter 'cancelPendingChangeRequest' is not null or undefined
            assertParamExists('cancelPendingChange', 'cancelPendingChangeRequest', cancelPendingChangeRequest)
            const localVarPath = `/api/v1/pending_changes/{pending_change_id}/cancel`
                .replace(`{${"pending_change_id"}}`, encodeURIComponent(String(pendingChangeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancelPendingChangeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Approve enable 2FA (code from app)
         * @param {TwoFAConfirmRequest} twoFAConfirmRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirm2FA: async (twoFAConfirmRequest: TwoFAConfirmRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'twoFAConfirmRequest' is not null or undefined
            assertParamExists('confirm2FA', 'twoFAConfirmRequest', twoFAConfirmRequest)
            const localVarPath = `/api/v1/users/me/2fa/confirm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(twoFAConfirmRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finishes the SAML authentication flow.   The Identity Provider sends an HTTP-POST request that contains **SAMLResponse** (mandatory, Base64-encoded `<samlp:Response>` XML) and the optional **RelayState** parameter.   On success the service creates a user session (cookie or JWT) and redirects the browser to the application UI. 
         * @summary Assertion Consumer Service (ACS) endpoint
         * @param {string} sAMLResponse Base64-encoded IdP &#x60;&lt;samlp:Response&gt;&#x60; document
         * @param {string} relayState Value round-tripped from the initial authentication request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumeSAMLAssertion: async (sAMLResponse: string, relayState: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sAMLResponse' is not null or undefined
            assertParamExists('consumeSAMLAssertion', 'sAMLResponse', sAMLResponse)
            // verify required parameter 'relayState' is not null or undefined
            assertParamExists('consumeSAMLAssertion', 'relayState', relayState)
            const localVarPath = `/api/v1/saml/acs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (sAMLResponse !== undefined) { 
                localVarFormParams.set('SAMLResponse', sAMLResponse as any);
            }
    
            if (relayState !== undefined) { 
                localVarFormParams.set('RelayState', relayState as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new category
         * @param {CreateCategoryRequest} createCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategory: async (createCategoryRequest: CreateCategoryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCategoryRequest' is not null or undefined
            assertParamExists('createCategory', 'createCategoryRequest', createCategoryRequest)
            const localVarPath = `/api/v1/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCategoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create environment
         * @param {string} projectId 
         * @param {CreateEnvironmentRequest} createEnvironmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironment: async (projectId: string, createEnvironmentRequest: CreateEnvironmentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createEnvironment', 'projectId', projectId)
            // verify required parameter 'createEnvironmentRequest' is not null or undefined
            assertParamExists('createEnvironment', 'createEnvironmentRequest', createEnvironmentRequest)
            const localVarPath = `/api/v1/projects/{project_id}/environments`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEnvironmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create flag variant for feature
         * @param {string} featureId 
         * @param {string} environmentKey 
         * @param {CreateFlagVariantRequest} createFlagVariantRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeatureFlagVariant: async (featureId: string, environmentKey: string, createFlagVariantRequest: CreateFlagVariantRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'featureId' is not null or undefined
            assertParamExists('createFeatureFlagVariant', 'featureId', featureId)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('createFeatureFlagVariant', 'environmentKey', environmentKey)
            // verify required parameter 'createFlagVariantRequest' is not null or undefined
            assertParamExists('createFeatureFlagVariant', 'createFlagVariantRequest', createFlagVariantRequest)
            const localVarPath = `/api/v1/features/{feature_id}/variants`
                .replace(`{${"feature_id"}}`, encodeURIComponent(String(featureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (environmentKey !== undefined) {
                localVarQueryParameter['environment_key'] = environmentKey;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFlagVariantRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create rule for feature
         * @param {string} featureId 
         * @param {string} environmentKey 
         * @param {CreateRuleRequest} createRuleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeatureRule: async (featureId: string, environmentKey: string, createRuleRequest: CreateRuleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'featureId' is not null or undefined
            assertParamExists('createFeatureRule', 'featureId', featureId)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('createFeatureRule', 'environmentKey', environmentKey)
            // verify required parameter 'createRuleRequest' is not null or undefined
            assertParamExists('createFeatureRule', 'createRuleRequest', createRuleRequest)
            const localVarPath = `/api/v1/features/{feature_id}/rules`
                .replace(`{${"feature_id"}}`, encodeURIComponent(String(featureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (environmentKey !== undefined) {
                localVarQueryParameter['environment_key'] = environmentKey;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create schedule for feature
         * @param {string} featureId 
         * @param {string} environmentKey 
         * @param {CreateFeatureScheduleRequest} createFeatureScheduleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeatureSchedule: async (featureId: string, environmentKey: string, createFeatureScheduleRequest: CreateFeatureScheduleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'featureId' is not null or undefined
            assertParamExists('createFeatureSchedule', 'featureId', featureId)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('createFeatureSchedule', 'environmentKey', environmentKey)
            // verify required parameter 'createFeatureScheduleRequest' is not null or undefined
            assertParamExists('createFeatureSchedule', 'createFeatureScheduleRequest', createFeatureScheduleRequest)
            const localVarPath = `/api/v1/features/{feature_id}/schedules`
                .replace(`{${"feature_id"}}`, encodeURIComponent(String(featureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (environmentKey !== undefined) {
                localVarQueryParameter['environment_key'] = environmentKey;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFeatureScheduleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create feature for project
         * @param {string} projectId 
         * @param {CreateFeatureRequest} createFeatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectFeature: async (projectId: string, createFeatureRequest: CreateFeatureRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createProjectFeature', 'projectId', projectId)
            // verify required parameter 'createFeatureRequest' is not null or undefined
            assertParamExists('createProjectFeature', 'createFeatureRequest', createFeatureRequest)
            const localVarPath = `/api/v1/projects/{project_id}/features`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFeatureRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create segment for project
         * @param {string} projectId 
         * @param {CreateSegmentRequest} createSegmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectSegment: async (projectId: string, createSegmentRequest: CreateSegmentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createProjectSegment', 'projectId', projectId)
            // verify required parameter 'createSegmentRequest' is not null or undefined
            assertParamExists('createProjectSegment', 'createSegmentRequest', createSegmentRequest)
            const localVarPath = `/api/v1/projects/{project_id}/segments`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSegmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create project setting
         * @param {string} projectId 
         * @param {CreateProjectSettingRequest} createProjectSettingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectSetting: async (projectId: string, createProjectSettingRequest: CreateProjectSettingRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createProjectSetting', 'projectId', projectId)
            // verify required parameter 'createProjectSettingRequest' is not null or undefined
            assertParamExists('createProjectSetting', 'createProjectSettingRequest', createProjectSettingRequest)
            const localVarPath = `/api/v1/projects/{project_id}/settings`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProjectSettingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new tag for project
         * @param {string} projectId 
         * @param {CreateProjectTagRequest} createProjectTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectTag: async (projectId: string, createProjectTagRequest: CreateProjectTagRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createProjectTag', 'projectId', projectId)
            // verify required parameter 'createProjectTagRequest' is not null or undefined
            assertParamExists('createProjectTag', 'createProjectTagRequest', createProjectTagRequest)
            const localVarPath = `/api/v1/projects/{project_id}/tags`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProjectTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create rule attribute
         * @param {CreateRuleAttributeRequest} createRuleAttributeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRuleAttribute: async (createRuleAttributeRequest: CreateRuleAttributeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRuleAttributeRequest' is not null or undefined
            assertParamExists('createRuleAttribute', 'createRuleAttributeRequest', createRuleAttributeRequest)
            const localVarPath = `/api/v1/rule_attributes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRuleAttributeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new user (superuser only)
         * @param {CreateUserRequest} createUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (createUserRequest: CreateUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserRequest' is not null or undefined
            assertParamExists('createUser', 'createUserRequest', createUserRequest)
            const localVarPath = `/api/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete category
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory: async (categoryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('deleteCategory', 'categoryId', categoryId)
            const localVarPath = `/api/v1/categories/{category_id}`
                .replace(`{${"category_id"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete environment
         * @param {number} environmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironment: async (environmentId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('deleteEnvironment', 'environmentId', environmentId)
            const localVarPath = `/api/v1/environments/{environment_id}`
                .replace(`{${"environment_id"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete feature
         * @param {string} featureId 
         * @param {string} environmentKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeature: async (featureId: string, environmentKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'featureId' is not null or undefined
            assertParamExists('deleteFeature', 'featureId', featureId)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('deleteFeature', 'environmentKey', environmentKey)
            const localVarPath = `/api/v1/features/{feature_id}`
                .replace(`{${"feature_id"}}`, encodeURIComponent(String(featureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (environmentKey !== undefined) {
                localVarQueryParameter['environment_key'] = environmentKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete feature schedule by ID
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeatureSchedule: async (scheduleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('deleteFeatureSchedule', 'scheduleId', scheduleId)
            const localVarPath = `/api/v1/feature-schedules/{schedule_id}`
                .replace(`{${"schedule_id"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete LDAP configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLDAPConfig: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/ldap/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete project setting
         * @param {string} projectId 
         * @param {string} settingName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectSetting: async (projectId: string, settingName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteProjectSetting', 'projectId', projectId)
            // verify required parameter 'settingName' is not null or undefined
            assertParamExists('deleteProjectSetting', 'settingName', settingName)
            const localVarPath = `/api/v1/projects/{project_id}/settings/{setting_name}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"setting_name"}}`, encodeURIComponent(String(settingName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete tag
         * @param {string} projectId 
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectTag: async (projectId: string, tagId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteProjectTag', 'projectId', projectId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('deleteProjectTag', 'tagId', tagId)
            const localVarPath = `/api/v1/projects/{project_id}/tags/{tag_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"tag_id"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete rule attribute
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRuleAttribute: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteRuleAttribute', 'name', name)
            const localVarPath = `/api/v1/rule_attributes/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete segment
         * @param {string} segmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSegment: async (segmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'segmentId' is not null or undefined
            assertParamExists('deleteSegment', 'segmentId', segmentId)
            const localVarPath = `/api/v1/segments/{segment_id}`
                .replace(`{${"segment_id"}}`, encodeURIComponent(String(segmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a user (superuser only, cannot delete superusers)
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUser', 'userId', userId)
            const localVarPath = `/api/v1/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Disable 2FA (using email-confirmation)
         * @param {TwoFADisableRequest} twoFADisableRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disable2FA: async (twoFADisableRequest: TwoFADisableRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'twoFADisableRequest' is not null or undefined
            assertParamExists('disable2FA', 'twoFADisableRequest', twoFADisableRequest)
            const localVarPath = `/api/v1/users/me/2fa/disable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(twoFADisableRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request a password reset
         * @param {ForgotPasswordRequest} forgotPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPassword: async (forgotPasswordRequest: ForgotPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'forgotPasswordRequest' is not null or undefined
            assertParamExists('forgotPassword', 'forgotPasswordRequest', forgotPasswordRequest)
            const localVarPath = `/api/v1/auth/forgot-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forgotPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get category details
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategory: async (categoryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('getCategory', 'categoryId', categoryId)
            const localVarPath = `/api/v1/categories/{category_id}`
                .replace(`{${"category_id"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get current user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get environment
         * @param {number} environmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironment: async (environmentId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironment', 'environmentId', environmentId)
            const localVarPath = `/api/v1/environments/{environment_id}`
                .replace(`{${"environment_id"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get feature with rules and variants
         * @param {string} featureId 
         * @param {string} environmentKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeature: async (featureId: string, environmentKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'featureId' is not null or undefined
            assertParamExists('getFeature', 'featureId', featureId)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getFeature', 'environmentKey', environmentKey)
            const localVarPath = `/api/v1/features/{feature_id}`
                .replace(`{${"feature_id"}}`, encodeURIComponent(String(featureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (environmentKey !== undefined) {
                localVarQueryParameter['environment_key'] = environmentKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get feature schedule by ID
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureSchedule: async (scheduleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('getFeatureSchedule', 'scheduleId', scheduleId)
            const localVarPath = `/api/v1/feature-schedules/{schedule_id}`
                .replace(`{${"schedule_id"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get feature timeline within period
         * @param {string} featureId 
         * @param {string} from Start of the period (inclusive)
         * @param {string} to End of the period (exclusive)
         * @param {string} location Browser\&#39;s location string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureTimeline: async (featureId: string, from: string, to: string, location: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'featureId' is not null or undefined
            assertParamExists('getFeatureTimeline', 'featureId', featureId)
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getFeatureTimeline', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getFeatureTimeline', 'to', to)
            // verify required parameter 'location' is not null or undefined
            assertParamExists('getFeatureTimeline', 'location', location)
            const localVarPath = `/api/v1/features/{feature_id}/timeline`
                .replace(`{${"feature_id"}}`, encodeURIComponent(String(featureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get LDAP configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLDAPConfig: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/ldap/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get LDAP statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLDAPStatistics: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/ldap/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get synchronization log details
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLDAPSyncLogDetails: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getLDAPSyncLogDetails', 'id', id)
            const localVarPath = `/api/v1/ldap/sync/logs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get synchronization logs
         * @param {number} [limit] 
         * @param {GetLDAPSyncLogsLevelEnum} [level] 
         * @param {string} [syncId] 
         * @param {string} [username] 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLDAPSyncLogs: async (limit?: number, level?: GetLDAPSyncLogsLevelEnum, syncId?: string, username?: string, from?: string, to?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/ldap/sync/logs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (syncId !== undefined) {
                localVarQueryParameter['sync_id'] = syncId;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get synchronization progress
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLDAPSyncProgress: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/ldap/sync/progress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get synchronization status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLDAPSyncStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/ldap/sync/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the current license status including validity, expiration date, and type
         * @summary Get license status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicenseStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/license/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get pending change by ID
         * @param {string} pendingChangeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPendingChange: async (pendingChangeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pendingChangeId' is not null or undefined
            assertParamExists('getPendingChange', 'pendingChangeId', pendingChangeId)
            const localVarPath = `/api/v1/pending_changes/{pending_change_id}`
                .replace(`{${"pending_change_id"}}`, encodeURIComponent(String(pendingChangeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get product information including client ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/product/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get project details
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProject', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{project_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get project setting by name
         * @param {string} projectId 
         * @param {string} settingName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSetting: async (projectId: string, settingName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProjectSetting', 'projectId', projectId)
            // verify required parameter 'settingName' is not null or undefined
            assertParamExists('getProjectSetting', 'settingName', settingName)
            const localVarPath = `/api/v1/projects/{project_id}/settings/{setting_name}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"setting_name"}}`, encodeURIComponent(String(settingName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get tag details
         * @param {string} projectId 
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectTag: async (projectId: string, tagId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProjectTag', 'projectId', projectId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('getProjectTag', 'tagId', tagId)
            const localVarPath = `/api/v1/projects/{project_id}/tags/{tag_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"tag_id"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get SAML metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSAMLMetadata: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/saml/metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get available SSO providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSSOProviders: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/sso/providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get segment by ID
         * @param {string} segmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegment: async (segmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'segmentId' is not null or undefined
            assertParamExists('getSegment', 'segmentId', segmentId)
            const localVarPath = `/api/v1/segments/{segment_id}`
                .replace(`{${"segment_id"}}`, encodeURIComponent(String(segmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Initiate TOTP approval session
         * @param {string} pendingChangeId 
         * @param {InitiateTOTPApprovalRequest} initiateTOTPApprovalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateTOTPApproval: async (pendingChangeId: string, initiateTOTPApprovalRequest: InitiateTOTPApprovalRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pendingChangeId' is not null or undefined
            assertParamExists('initiateTOTPApproval', 'pendingChangeId', pendingChangeId)
            // verify required parameter 'initiateTOTPApprovalRequest' is not null or undefined
            assertParamExists('initiateTOTPApproval', 'initiateTOTPApprovalRequest', initiateTOTPApprovalRequest)
            const localVarPath = `/api/v1/pending_changes/{pending_change_id}/initiate-totp`
                .replace(`{${"pending_change_id"}}`, encodeURIComponent(String(pendingChangeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(initiateTOTPApprovalRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all feature schedules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllFeatureSchedules: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/feature-schedules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get categories list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCategories: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List flag variants for feature
         * @param {string} featureId 
         * @param {string} environmentKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFeatureFlagVariants: async (featureId: string, environmentKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'featureId' is not null or undefined
            assertParamExists('listFeatureFlagVariants', 'featureId', featureId)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('listFeatureFlagVariants', 'environmentKey', environmentKey)
            const localVarPath = `/api/v1/features/{feature_id}/variants`
                .replace(`{${"feature_id"}}`, encodeURIComponent(String(featureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (environmentKey !== undefined) {
                localVarQueryParameter['environment_key'] = environmentKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List rules for feature
         * @param {string} featureId 
         * @param {string} environmentKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFeatureRules: async (featureId: string, environmentKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'featureId' is not null or undefined
            assertParamExists('listFeatureRules', 'featureId', featureId)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('listFeatureRules', 'environmentKey', environmentKey)
            const localVarPath = `/api/v1/features/{feature_id}/rules`
                .replace(`{${"feature_id"}}`, encodeURIComponent(String(featureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (environmentKey !== undefined) {
                localVarQueryParameter['environment_key'] = environmentKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List schedules for feature
         * @param {string} featureId 
         * @param {string} environmentKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFeatureSchedules: async (featureId: string, environmentKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'featureId' is not null or undefined
            assertParamExists('listFeatureSchedules', 'featureId', featureId)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('listFeatureSchedules', 'environmentKey', environmentKey)
            const localVarPath = `/api/v1/features/{feature_id}/schedules`
                .replace(`{${"feature_id"}}`, encodeURIComponent(String(featureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (environmentKey !== undefined) {
                localVarQueryParameter['environment_key'] = environmentKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List feature tags
         * @param {string} featureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFeatureTags: async (featureId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'featureId' is not null or undefined
            assertParamExists('listFeatureTags', 'featureId', featureId)
            const localVarPath = `/api/v1/features/{feature_id}/tags`
                .replace(`{${"feature_id"}}`, encodeURIComponent(String(featureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List pending changes
         * @param {number} [environmentId] 
         * @param {string} [projectId] 
         * @param {ListPendingChangesStatusEnum} [status] 
         * @param {number} [userId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {ListPendingChangesSortByEnum} [sortBy] 
         * @param {boolean} [sortDesc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPendingChanges: async (environmentId?: number, projectId?: string, status?: ListPendingChangesStatusEnum, userId?: number, page?: number, perPage?: number, sortBy?: ListPendingChangesSortByEnum, sortDesc?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/pending_changes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (environmentId !== undefined) {
                localVarQueryParameter['environment_id'] = environmentId;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortDesc !== undefined) {
                localVarQueryParameter['sort_desc'] = sortDesc;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get history of changes made to project features, rules, and other entities grouped by request_id
         * @summary Get project changes history
         * @param {string} projectId Project ID
         * @param {number} [page] Page number (starts from 1)
         * @param {number} [perPage] Items per page
         * @param {ListProjectChangesSortByEnum} [sortBy] Sort by field
         * @param {SortOrder} [sortOrder] Sort order
         * @param {string} [actor] Filter by actor (system, sdk, user:&lt;user_id&gt;)
         * @param {EntityType} [entity] Filter by entity type
         * @param {AuditAction} [action] Filter by action type
         * @param {string} [featureId] Filter by specific feature ID
         * @param {string} [from] Filter changes from this date (ISO 8601 format)
         * @param {string} [to] Filter changes until this date (ISO 8601 format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectChanges: async (projectId: string, page?: number, perPage?: number, sortBy?: ListProjectChangesSortByEnum, sortOrder?: SortOrder, actor?: string, entity?: EntityType, action?: AuditAction, featureId?: string, from?: string, to?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('listProjectChanges', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{project_id}/changes`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (actor !== undefined) {
                localVarQueryParameter['actor'] = actor;
            }

            if (entity !== undefined) {
                localVarQueryParameter['entity'] = entity;
            }

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }

            if (featureId !== undefined) {
                localVarQueryParameter['feature_id'] = featureId;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List project environments
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectEnvironments: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('listProjectEnvironments', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{project_id}/environments`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List features for project
         * @param {string} projectId 
         * @param {string} environmentKey Environment key (dev, stage, prod) to filter features
         * @param {ListProjectFeaturesKindEnum} [kind] Filter by feature kind
         * @param {boolean} [enabled] Filter by enabled state
         * @param {string} [textSelector] Case-insensitive text search across key, name, description, rollout_key
         * @param {string} [tagIds] Filter by tag IDs (comma-separated)
         * @param {ListProjectFeaturesSortByEnum} [sortBy] Sort by field
         * @param {SortOrder} [sortOrder] Sort order
         * @param {number} [page] Page number (starts from 1)
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectFeatures: async (projectId: string, environmentKey: string, kind?: ListProjectFeaturesKindEnum, enabled?: boolean, textSelector?: string, tagIds?: string, sortBy?: ListProjectFeaturesSortByEnum, sortOrder?: SortOrder, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('listProjectFeatures', 'projectId', projectId)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('listProjectFeatures', 'environmentKey', environmentKey)
            const localVarPath = `/api/v1/projects/{project_id}/features`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (environmentKey !== undefined) {
                localVarQueryParameter['environment_key'] = environmentKey;
            }

            if (kind !== undefined) {
                localVarQueryParameter['kind'] = kind;
            }

            if (enabled !== undefined) {
                localVarQueryParameter['enabled'] = enabled;
            }

            if (textSelector !== undefined) {
                localVarQueryParameter['text_selector'] = textSelector;
            }

            if (tagIds !== undefined) {
                localVarQueryParameter['tag_ids'] = tagIds;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List segments for project
         * @param {string} projectId 
         * @param {string} [textSelector] Case-insensitive text search across name, description
         * @param {ListProjectSegmentsSortByEnum} [sortBy] Sort by field
         * @param {SortOrder} [sortOrder] Sort order
         * @param {number} [page] Page number (starts from 1)
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectSegments: async (projectId: string, textSelector?: string, sortBy?: ListProjectSegmentsSortByEnum, sortOrder?: SortOrder, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('listProjectSegments', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{project_id}/segments`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (textSelector !== undefined) {
                localVarQueryParameter['text_selector'] = textSelector;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List project settings
         * @param {string} projectId 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectSettings: async (projectId: string, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('listProjectSettings', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{project_id}/settings`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get tags list for project
         * @param {string} projectId 
         * @param {string} [categoryId] Filter by category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectTags: async (projectId: string, categoryId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('listProjectTags', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{project_id}/tags`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (categoryId !== undefined) {
                localVarQueryParameter['category_id'] = categoryId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get projects list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List of rule attributes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuleAttributes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/rule_attributes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get desync feature IDs by segment ID
         * @param {string} segmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSegmentDesyncFeatureIDs: async (segmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'segmentId' is not null or undefined
            assertParamExists('listSegmentDesyncFeatureIDs', 'segmentId', segmentId)
            const localVarPath = `/api/v1/segments/{segment_id}/desync-features`
                .replace(`{${"segment_id"}}`, encodeURIComponent(String(segmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all users (superuser only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Authenticate user and get access token
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginRequest: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('login', 'loginRequest', loginRequest)
            const localVarPath = `/api/v1/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refresh access token
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (refreshTokenRequest: RefreshTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshTokenRequest' is not null or undefined
            assertParamExists('refreshToken', 'refreshTokenRequest', refreshTokenRequest)
            const localVarPath = `/api/v1/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reject a pending change
         * @param {string} pendingChangeId 
         * @param {RejectPendingChangeRequest} rejectPendingChangeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectPendingChange: async (pendingChangeId: string, rejectPendingChangeRequest: RejectPendingChangeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pendingChangeId' is not null or undefined
            assertParamExists('rejectPendingChange', 'pendingChangeId', pendingChangeId)
            // verify required parameter 'rejectPendingChangeRequest' is not null or undefined
            assertParamExists('rejectPendingChange', 'rejectPendingChangeRequest', rejectPendingChangeRequest)
            const localVarPath = `/api/v1/pending_changes/{pending_change_id}/reject`
                .replace(`{${"pending_change_id"}}`, encodeURIComponent(String(pendingChangeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rejectPendingChangeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove tag from feature
         * @param {string} featureId 
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFeatureTag: async (featureId: string, tagId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'featureId' is not null or undefined
            assertParamExists('removeFeatureTag', 'featureId', featureId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('removeFeatureTag', 'tagId', tagId)
            const localVarPath = `/api/v1/features/{feature_id}/tags`
                .replace(`{${"feature_id"}}`, encodeURIComponent(String(featureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (tagId !== undefined) {
                localVarQueryParameter['tag_id'] = tagId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset/generate secret 2FA (using email-confirmation)
         * @param {TwoFAResetRequest} twoFAResetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reset2FA: async (twoFAResetRequest: TwoFAResetRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'twoFAResetRequest' is not null or undefined
            assertParamExists('reset2FA', 'twoFAResetRequest', twoFAResetRequest)
            const localVarPath = `/api/v1/users/me/2fa/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(twoFAResetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset password using token
         * @param {ResetPasswordRequest} resetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword: async (resetPasswordRequest: ResetPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetPasswordRequest' is not null or undefined
            assertParamExists('resetPassword', 'resetPasswordRequest', resetPasswordRequest)
            const localVarPath = `/api/v1/auth/reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Handle SSO callback from Keycloak
         * @param {SSOCallbackRequest} sSOCallbackRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sSOCallback: async (sSOCallbackRequest: SSOCallbackRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sSOCallbackRequest' is not null or undefined
            assertParamExists('sSOCallback', 'sSOCallbackRequest', sSOCallbackRequest)
            const localVarPath = `/api/v1/auth/sso/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sSOCallbackRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Initiate SSO login flow
         * @param {string} provider Name of the SSO provider to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sSOInitiate: async (provider: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('sSOInitiate', 'provider', provider)
            const localVarPath = `/api/v1/auth/sso/initiate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set or unset superuser status (superuser only, cannot modify admin user)
         * @param {number} userId 
         * @param {SetSuperuserStatusRequest} setSuperuserStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSuperuserStatus: async (userId: number, setSuperuserStatusRequest: SetSuperuserStatusRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('setSuperuserStatus', 'userId', userId)
            // verify required parameter 'setSuperuserStatusRequest' is not null or undefined
            assertParamExists('setSuperuserStatus', 'setSuperuserStatusRequest', setSuperuserStatusRequest)
            const localVarPath = `/api/v1/users/{user_id}/superuser`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setSuperuserStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set or unset user active status (superuser only)
         * @param {number} userId 
         * @param {SetUserActiveStatusRequest} setUserActiveStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserActiveStatus: async (userId: number, setUserActiveStatusRequest: SetUserActiveStatusRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('setUserActiveStatus', 'userId', userId)
            // verify required parameter 'setUserActiveStatusRequest' is not null or undefined
            assertParamExists('setUserActiveStatus', 'setUserActiveStatusRequest', setUserActiveStatusRequest)
            const localVarPath = `/api/v1/users/{user_id}/active`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setUserActiveStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Begin setup 2FA (generate secret and QR-code)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setup2FA: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/me/2fa/setup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Synchronize customized feature rule
         * @param {string} featureId 
         * @param {string} ruleId 
         * @param {string} environmentKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncCustomizedFeatureRule: async (featureId: string, ruleId: string, environmentKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'featureId' is not null or undefined
            assertParamExists('syncCustomizedFeatureRule', 'featureId', featureId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('syncCustomizedFeatureRule', 'ruleId', ruleId)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('syncCustomizedFeatureRule', 'environmentKey', environmentKey)
            const localVarPath = `/api/v1/features/{feature_id}/rules/{rule_id}/sync`
                .replace(`{${"feature_id"}}`, encodeURIComponent(String(featureId)))
                .replace(`{${"rule_id"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (environmentKey !== undefined) {
                localVarQueryParameter['environment_key'] = environmentKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start user synchronization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncLDAPUsers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/ldap/sync/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Test feature timeline with mock schedules
         * @param {string} featureId 
         * @param {string} from Start of the period (inclusive)
         * @param {string} to End of the period (exclusive)
         * @param {string} location Browser\&#39;s location string
         * @param {TestFeatureTimelineRequest} testFeatureTimelineRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testFeatureTimeline: async (featureId: string, from: string, to: string, location: string, testFeatureTimelineRequest: TestFeatureTimelineRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'featureId' is not null or undefined
            assertParamExists('testFeatureTimeline', 'featureId', featureId)
            // verify required parameter 'from' is not null or undefined
            assertParamExists('testFeatureTimeline', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('testFeatureTimeline', 'to', to)
            // verify required parameter 'location' is not null or undefined
            assertParamExists('testFeatureTimeline', 'location', location)
            // verify required parameter 'testFeatureTimelineRequest' is not null or undefined
            assertParamExists('testFeatureTimeline', 'testFeatureTimelineRequest', testFeatureTimelineRequest)
            const localVarPath = `/api/v1/features/{feature_id}/timeline/test`
                .replace(`{${"feature_id"}}`, encodeURIComponent(String(featureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(testFeatureTimelineRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Test LDAP connection
         * @param {LDAPConnectionTest} lDAPConnectionTest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testLDAPConnection: async (lDAPConnectionTest: LDAPConnectionTest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lDAPConnectionTest' is not null or undefined
            assertParamExists('testLDAPConnection', 'lDAPConnectionTest', lDAPConnectionTest)
            const localVarPath = `/api/v1/ldap/test-connection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lDAPConnectionTest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Toggle feature enabled state
         * @param {string} featureId 
         * @param {string} environmentKey 
         * @param {ToggleFeatureRequest} toggleFeatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleFeature: async (featureId: string, environmentKey: string, toggleFeatureRequest: ToggleFeatureRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'featureId' is not null or undefined
            assertParamExists('toggleFeature', 'featureId', featureId)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('toggleFeature', 'environmentKey', environmentKey)
            // verify required parameter 'toggleFeatureRequest' is not null or undefined
            assertParamExists('toggleFeature', 'toggleFeatureRequest', toggleFeatureRequest)
            const localVarPath = `/api/v1/features/{feature_id}/toggle`
                .replace(`{${"feature_id"}}`, encodeURIComponent(String(featureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (environmentKey !== undefined) {
                localVarQueryParameter['environment_key'] = environmentKey;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(toggleFeatureRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update category
         * @param {string} categoryId 
         * @param {UpdateCategoryRequest} updateCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory: async (categoryId: string, updateCategoryRequest: UpdateCategoryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('updateCategory', 'categoryId', categoryId)
            // verify required parameter 'updateCategoryRequest' is not null or undefined
            assertParamExists('updateCategory', 'updateCategoryRequest', updateCategoryRequest)
            const localVarPath = `/api/v1/categories/{category_id}`
                .replace(`{${"category_id"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCategoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update environment
         * @param {number} environmentId 
         * @param {UpdateEnvironmentRequest} updateEnvironmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEnvironment: async (environmentId: number, updateEnvironmentRequest: UpdateEnvironmentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('updateEnvironment', 'environmentId', environmentId)
            // verify required parameter 'updateEnvironmentRequest' is not null or undefined
            assertParamExists('updateEnvironment', 'updateEnvironmentRequest', updateEnvironmentRequest)
            const localVarPath = `/api/v1/environments/{environment_id}`
                .replace(`{${"environment_id"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEnvironmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update feature with rules and variants
         * @param {string} featureId 
         * @param {string} environmentKey 
         * @param {CreateFeatureRequest} createFeatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeature: async (featureId: string, environmentKey: string, createFeatureRequest: CreateFeatureRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'featureId' is not null or undefined
            assertParamExists('updateFeature', 'featureId', featureId)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('updateFeature', 'environmentKey', environmentKey)
            // verify required parameter 'createFeatureRequest' is not null or undefined
            assertParamExists('updateFeature', 'createFeatureRequest', createFeatureRequest)
            const localVarPath = `/api/v1/features/{feature_id}`
                .replace(`{${"feature_id"}}`, encodeURIComponent(String(featureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (environmentKey !== undefined) {
                localVarQueryParameter['environment_key'] = environmentKey;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFeatureRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update feature schedule by ID
         * @param {string} scheduleId 
         * @param {UpdateFeatureScheduleRequest} updateFeatureScheduleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeatureSchedule: async (scheduleId: string, updateFeatureScheduleRequest: UpdateFeatureScheduleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('updateFeatureSchedule', 'scheduleId', scheduleId)
            // verify required parameter 'updateFeatureScheduleRequest' is not null or undefined
            assertParamExists('updateFeatureSchedule', 'updateFeatureScheduleRequest', updateFeatureScheduleRequest)
            const localVarPath = `/api/v1/feature-schedules/{schedule_id}`
                .replace(`{${"schedule_id"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFeatureScheduleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create or update LDAP configuration
         * @param {LDAPConfig} lDAPConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLDAPConfig: async (lDAPConfig: LDAPConfig, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lDAPConfig' is not null or undefined
            assertParamExists('updateLDAPConfig', 'lDAPConfig', lDAPConfig)
            const localVarPath = `/api/v1/ldap/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lDAPConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the system license with a new license key
         * @summary Update license
         * @param {UpdateLicenseRequest} updateLicenseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLicense: async (updateLicenseRequest: UpdateLicenseRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateLicenseRequest' is not null or undefined
            assertParamExists('updateLicense', 'updateLicenseRequest', updateLicenseRequest)
            const localVarPath = `/api/v1/license`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateLicenseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update license acceptance status
         * @param {UpdateLicenseAcceptanceRequest} updateLicenseAcceptanceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLicenseAcceptance: async (updateLicenseAcceptanceRequest: UpdateLicenseAcceptanceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateLicenseAcceptanceRequest' is not null or undefined
            assertParamExists('updateLicenseAcceptance', 'updateLicenseAcceptanceRequest', updateLicenseAcceptanceRequest)
            const localVarPath = `/api/v1/users/me/license-acceptance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateLicenseAcceptanceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update project name and description
         * @param {string} projectId 
         * @param {UpdateProjectRequest} updateProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject: async (projectId: string, updateProjectRequest: UpdateProjectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateProject', 'projectId', projectId)
            // verify required parameter 'updateProjectRequest' is not null or undefined
            assertParamExists('updateProject', 'updateProjectRequest', updateProjectRequest)
            const localVarPath = `/api/v1/projects/{project_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProjectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update project setting
         * @param {string} projectId 
         * @param {string} settingName 
         * @param {UpdateProjectSettingRequest} updateProjectSettingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectSetting: async (projectId: string, settingName: string, updateProjectSettingRequest: UpdateProjectSettingRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateProjectSetting', 'projectId', projectId)
            // verify required parameter 'settingName' is not null or undefined
            assertParamExists('updateProjectSetting', 'settingName', settingName)
            // verify required parameter 'updateProjectSettingRequest' is not null or undefined
            assertParamExists('updateProjectSetting', 'updateProjectSettingRequest', updateProjectSettingRequest)
            const localVarPath = `/api/v1/projects/{project_id}/settings/{setting_name}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"setting_name"}}`, encodeURIComponent(String(settingName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProjectSettingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update tag
         * @param {string} projectId 
         * @param {string} tagId 
         * @param {UpdateProjectTagRequest} updateProjectTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectTag: async (projectId: string, tagId: string, updateProjectTagRequest: UpdateProjectTagRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateProjectTag', 'projectId', projectId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('updateProjectTag', 'tagId', tagId)
            // verify required parameter 'updateProjectTagRequest' is not null or undefined
            assertParamExists('updateProjectTag', 'updateProjectTagRequest', updateProjectTagRequest)
            const localVarPath = `/api/v1/projects/{project_id}/tags/{tag_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"tag_id"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProjectTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update segment
         * @param {string} segmentId 
         * @param {UpdateSegmentRequest} updateSegmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSegment: async (segmentId: string, updateSegmentRequest: UpdateSegmentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'segmentId' is not null or undefined
            assertParamExists('updateSegment', 'segmentId', segmentId)
            // verify required parameter 'updateSegmentRequest' is not null or undefined
            assertParamExists('updateSegment', 'updateSegmentRequest', updateSegmentRequest)
            const localVarPath = `/api/v1/segments/{segment_id}`
                .replace(`{${"segment_id"}}`, encodeURIComponent(String(segmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSegmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change my password
         * @param {ChangeUserPasswordRequest} changeUserPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userChangeMyPassword: async (changeUserPasswordRequest: ChangeUserPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changeUserPasswordRequest' is not null or undefined
            assertParamExists('userChangeMyPassword', 'changeUserPasswordRequest', changeUserPasswordRequest)
            const localVarPath = `/api/v1/users/me/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changeUserPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verify 2FA-code on login
         * @param {TwoFAVerifyRequest} twoFAVerifyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verify2FA: async (twoFAVerifyRequest: TwoFAVerifyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'twoFAVerifyRequest' is not null or undefined
            assertParamExists('verify2FA', 'twoFAVerifyRequest', twoFAVerifyRequest)
            const localVarPath = `/api/v1/auth/2fa/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(twoFAVerifyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add tag to feature
         * @param {string} featureId 
         * @param {AddFeatureTagRequest} addFeatureTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addFeatureTag(featureId: string, addFeatureTagRequest: AddFeatureTagRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addFeatureTag(featureId, addFeatureTagRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.addFeatureTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add new project
         * @param {AddProjectRequest} addProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addProject(addProjectRequest: AddProjectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addProject(addProjectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.addProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Approve a pending change
         * @param {string} pendingChangeId 
         * @param {ApprovePendingChangeRequest} approvePendingChangeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approvePendingChange(pendingChangeId: string, approvePendingChangeRequest: ApprovePendingChangeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approvePendingChange(pendingChangeId, approvePendingChangeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.approvePendingChange']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Archive a project
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archiveProject(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.archiveProject(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.archiveProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Cancel ongoing synchronization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelLDAPSync(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelLDAPSync(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.cancelLDAPSync']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Cancel a pending change
         * @param {string} pendingChangeId 
         * @param {CancelPendingChangeRequest} cancelPendingChangeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelPendingChange(pendingChangeId: string, cancelPendingChangeRequest: CancelPendingChangeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelPendingChange(pendingChangeId, cancelPendingChangeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.cancelPendingChange']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Approve enable 2FA (code from app)
         * @param {TwoFAConfirmRequest} twoFAConfirmRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirm2FA(twoFAConfirmRequest: TwoFAConfirmRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirm2FA(twoFAConfirmRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.confirm2FA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Finishes the SAML authentication flow.   The Identity Provider sends an HTTP-POST request that contains **SAMLResponse** (mandatory, Base64-encoded `<samlp:Response>` XML) and the optional **RelayState** parameter.   On success the service creates a user session (cookie or JWT) and redirects the browser to the application UI. 
         * @summary Assertion Consumer Service (ACS) endpoint
         * @param {string} sAMLResponse Base64-encoded IdP &#x60;&lt;samlp:Response&gt;&#x60; document
         * @param {string} relayState Value round-tripped from the initial authentication request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async consumeSAMLAssertion(sAMLResponse: string, relayState: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Error>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.consumeSAMLAssertion(sAMLResponse, relayState, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.consumeSAMLAssertion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create new category
         * @param {CreateCategoryRequest} createCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCategory(createCategoryRequest: CreateCategoryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCategory(createCategoryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create environment
         * @param {string} projectId 
         * @param {CreateEnvironmentRequest} createEnvironmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnvironment(projectId: string, createEnvironmentRequest: CreateEnvironmentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironment(projectId, createEnvironmentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createEnvironment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create flag variant for feature
         * @param {string} featureId 
         * @param {string} environmentKey 
         * @param {CreateFlagVariantRequest} createFlagVariantRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFeatureFlagVariant(featureId: string, environmentKey: string, createFlagVariantRequest: CreateFlagVariantRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlagVariantResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFeatureFlagVariant(featureId, environmentKey, createFlagVariantRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createFeatureFlagVariant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create rule for feature
         * @param {string} featureId 
         * @param {string} environmentKey 
         * @param {CreateRuleRequest} createRuleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFeatureRule(featureId: string, environmentKey: string, createRuleRequest: CreateRuleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFeatureRule(featureId, environmentKey, createRuleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createFeatureRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create schedule for feature
         * @param {string} featureId 
         * @param {string} environmentKey 
         * @param {CreateFeatureScheduleRequest} createFeatureScheduleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFeatureSchedule(featureId: string, environmentKey: string, createFeatureScheduleRequest: CreateFeatureScheduleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureScheduleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFeatureSchedule(featureId, environmentKey, createFeatureScheduleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createFeatureSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create feature for project
         * @param {string} projectId 
         * @param {CreateFeatureRequest} createFeatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProjectFeature(projectId: string, createFeatureRequest: CreateFeatureRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProjectFeature(projectId, createFeatureRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createProjectFeature']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create segment for project
         * @param {string} projectId 
         * @param {CreateSegmentRequest} createSegmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProjectSegment(projectId: string, createSegmentRequest: CreateSegmentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SegmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProjectSegment(projectId, createSegmentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createProjectSegment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create project setting
         * @param {string} projectId 
         * @param {CreateProjectSettingRequest} createProjectSettingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProjectSetting(projectId: string, createProjectSettingRequest: CreateProjectSettingRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectSettingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProjectSetting(projectId, createProjectSettingRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createProjectSetting']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create new tag for project
         * @param {string} projectId 
         * @param {CreateProjectTagRequest} createProjectTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProjectTag(projectId: string, createProjectTagRequest: CreateProjectTagRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectTagResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProjectTag(projectId, createProjectTagRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createProjectTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create rule attribute
         * @param {CreateRuleAttributeRequest} createRuleAttributeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRuleAttribute(createRuleAttributeRequest: CreateRuleAttributeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRuleAttribute(createRuleAttributeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createRuleAttribute']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new user (superuser only)
         * @param {CreateUserRequest} createUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(createUserRequest: CreateUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(createUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete category
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCategory(categoryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCategory(categoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete environment
         * @param {number} environmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEnvironment(environmentId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEnvironment(environmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteEnvironment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete feature
         * @param {string} featureId 
         * @param {string} environmentKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFeature(featureId: string, environmentKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PendingChangeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFeature(featureId, environmentKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteFeature']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete feature schedule by ID
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFeatureSchedule(scheduleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFeatureSchedule(scheduleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteFeatureSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete LDAP configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLDAPConfig(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLDAPConfig(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteLDAPConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete project setting
         * @param {string} projectId 
         * @param {string} settingName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProjectSetting(projectId: string, settingName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProjectSetting(projectId, settingName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteProjectSetting']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete tag
         * @param {string} projectId 
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProjectTag(projectId: string, tagId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProjectTag(projectId, tagId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteProjectTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete rule attribute
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRuleAttribute(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRuleAttribute(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteRuleAttribute']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete segment
         * @param {string} segmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSegment(segmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSegment(segmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteSegment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a user (superuser only, cannot delete superusers)
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Disable 2FA (using email-confirmation)
         * @param {TwoFADisableRequest} twoFADisableRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disable2FA(twoFADisableRequest: TwoFADisableRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disable2FA(twoFADisableRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.disable2FA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Request a password reset
         * @param {ForgotPasswordRequest} forgotPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forgotPassword(forgotPasswordRequest: ForgotPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forgotPassword(forgotPasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.forgotPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get category details
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategory(categoryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategory(categoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get current user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getCurrentUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get environment
         * @param {number} environmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironment(environmentId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironment(environmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getEnvironment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get feature with rules and variants
         * @param {string} featureId 
         * @param {string} environmentKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeature(featureId: string, environmentKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureDetailsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeature(featureId, environmentKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getFeature']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get feature schedule by ID
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeatureSchedule(scheduleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureScheduleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeatureSchedule(scheduleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getFeatureSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get feature timeline within period
         * @param {string} featureId 
         * @param {string} from Start of the period (inclusive)
         * @param {string} to End of the period (exclusive)
         * @param {string} location Browser\&#39;s location string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeatureTimeline(featureId: string, from: string, to: string, location: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureTimelineResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeatureTimeline(featureId, from, to, location, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getFeatureTimeline']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get LDAP configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLDAPConfig(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LDAPConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLDAPConfig(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getLDAPConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get LDAP statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLDAPStatistics(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LDAPStatistics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLDAPStatistics(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getLDAPStatistics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get synchronization log details
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLDAPSyncLogDetails(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LDAPSyncLogDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLDAPSyncLogDetails(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getLDAPSyncLogDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get synchronization logs
         * @param {number} [limit] 
         * @param {GetLDAPSyncLogsLevelEnum} [level] 
         * @param {string} [syncId] 
         * @param {string} [username] 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLDAPSyncLogs(limit?: number, level?: GetLDAPSyncLogsLevelEnum, syncId?: string, username?: string, from?: string, to?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LDAPSyncLogs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLDAPSyncLogs(limit, level, syncId, username, from, to, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getLDAPSyncLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get synchronization progress
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLDAPSyncProgress(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LDAPSyncProgress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLDAPSyncProgress(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getLDAPSyncProgress']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get synchronization status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLDAPSyncStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LDAPSyncStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLDAPSyncStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getLDAPSyncStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the current license status including validity, expiration date, and type
         * @summary Get license status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLicenseStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LicenseStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLicenseStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getLicenseStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get pending change by ID
         * @param {string} pendingChangeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPendingChange(pendingChangeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PendingChangeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPendingChange(pendingChangeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getPendingChange']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get product information including client ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getProductInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get project details
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProject(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProject(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get project setting by name
         * @param {string} projectId 
         * @param {string} settingName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectSetting(projectId: string, settingName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectSettingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectSetting(projectId, settingName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getProjectSetting']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get tag details
         * @param {string} projectId 
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectTag(projectId: string, tagId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectTagResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectTag(projectId, tagId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getProjectTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get SAML metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSAMLMetadata(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSAMLMetadata(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getSAMLMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get available SSO providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSSOProviders(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SSOProvidersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSSOProviders(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getSSOProviders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get segment by ID
         * @param {string} segmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSegment(segmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SegmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSegment(segmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getSegment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Initiate TOTP approval session
         * @param {string} pendingChangeId 
         * @param {InitiateTOTPApprovalRequest} initiateTOTPApprovalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initiateTOTPApproval(pendingChangeId: string, initiateTOTPApprovalRequest: InitiateTOTPApprovalRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InitiateTOTPApprovalResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initiateTOTPApproval(pendingChangeId, initiateTOTPApprovalRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.initiateTOTPApproval']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all feature schedules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllFeatureSchedules(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FeatureSchedule>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllFeatureSchedules(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listAllFeatureSchedules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get categories list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCategories(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Category>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCategories(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List flag variants for feature
         * @param {string} featureId 
         * @param {string} environmentKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFeatureFlagVariants(featureId: string, environmentKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FlagVariant>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFeatureFlagVariants(featureId, environmentKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listFeatureFlagVariants']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List rules for feature
         * @param {string} featureId 
         * @param {string} environmentKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFeatureRules(featureId: string, environmentKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Rule>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFeatureRules(featureId, environmentKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listFeatureRules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List schedules for feature
         * @param {string} featureId 
         * @param {string} environmentKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFeatureSchedules(featureId: string, environmentKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FeatureSchedule>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFeatureSchedules(featureId, environmentKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listFeatureSchedules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List feature tags
         * @param {string} featureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFeatureTags(featureId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProjectTag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFeatureTags(featureId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listFeatureTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List pending changes
         * @param {number} [environmentId] 
         * @param {string} [projectId] 
         * @param {ListPendingChangesStatusEnum} [status] 
         * @param {number} [userId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {ListPendingChangesSortByEnum} [sortBy] 
         * @param {boolean} [sortDesc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPendingChanges(environmentId?: number, projectId?: string, status?: ListPendingChangesStatusEnum, userId?: number, page?: number, perPage?: number, sortBy?: ListPendingChangesSortByEnum, sortDesc?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PendingChangesListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPendingChanges(environmentId, projectId, status, userId, page, perPage, sortBy, sortDesc, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listPendingChanges']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get history of changes made to project features, rules, and other entities grouped by request_id
         * @summary Get project changes history
         * @param {string} projectId Project ID
         * @param {number} [page] Page number (starts from 1)
         * @param {number} [perPage] Items per page
         * @param {ListProjectChangesSortByEnum} [sortBy] Sort by field
         * @param {SortOrder} [sortOrder] Sort order
         * @param {string} [actor] Filter by actor (system, sdk, user:&lt;user_id&gt;)
         * @param {EntityType} [entity] Filter by entity type
         * @param {AuditAction} [action] Filter by action type
         * @param {string} [featureId] Filter by specific feature ID
         * @param {string} [from] Filter changes from this date (ISO 8601 format)
         * @param {string} [to] Filter changes until this date (ISO 8601 format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjectChanges(projectId: string, page?: number, perPage?: number, sortBy?: ListProjectChangesSortByEnum, sortOrder?: SortOrder, actor?: string, entity?: EntityType, action?: AuditAction, featureId?: string, from?: string, to?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListChangesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjectChanges(projectId, page, perPage, sortBy, sortOrder, actor, entity, action, featureId, from, to, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listProjectChanges']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List project environments
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjectEnvironments(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListEnvironmentsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjectEnvironments(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listProjectEnvironments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List features for project
         * @param {string} projectId 
         * @param {string} environmentKey Environment key (dev, stage, prod) to filter features
         * @param {ListProjectFeaturesKindEnum} [kind] Filter by feature kind
         * @param {boolean} [enabled] Filter by enabled state
         * @param {string} [textSelector] Case-insensitive text search across key, name, description, rollout_key
         * @param {string} [tagIds] Filter by tag IDs (comma-separated)
         * @param {ListProjectFeaturesSortByEnum} [sortBy] Sort by field
         * @param {SortOrder} [sortOrder] Sort order
         * @param {number} [page] Page number (starts from 1)
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjectFeatures(projectId: string, environmentKey: string, kind?: ListProjectFeaturesKindEnum, enabled?: boolean, textSelector?: string, tagIds?: string, sortBy?: ListProjectFeaturesSortByEnum, sortOrder?: SortOrder, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListFeaturesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjectFeatures(projectId, environmentKey, kind, enabled, textSelector, tagIds, sortBy, sortOrder, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listProjectFeatures']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List segments for project
         * @param {string} projectId 
         * @param {string} [textSelector] Case-insensitive text search across name, description
         * @param {ListProjectSegmentsSortByEnum} [sortBy] Sort by field
         * @param {SortOrder} [sortOrder] Sort order
         * @param {number} [page] Page number (starts from 1)
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjectSegments(projectId: string, textSelector?: string, sortBy?: ListProjectSegmentsSortByEnum, sortOrder?: SortOrder, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListSegmentsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjectSegments(projectId, textSelector, sortBy, sortOrder, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listProjectSegments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List project settings
         * @param {string} projectId 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjectSettings(projectId: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListProjectSettingsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjectSettings(projectId, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listProjectSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get tags list for project
         * @param {string} projectId 
         * @param {string} [categoryId] Filter by category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjectTags(projectId: string, categoryId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProjectTag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjectTags(projectId, categoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listProjectTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get projects list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjects(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Project>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjects(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listProjects']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List of rule attributes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRuleAttributes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RuleAttributeEntity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRuleAttributes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listRuleAttributes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get desync feature IDs by segment ID
         * @param {string} segmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSegmentDesyncFeatureIDs(segmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSegmentDesyncFeatureIDs(segmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listSegmentDesyncFeatureIDs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all users (superuser only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Authenticate user and get access token
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Refresh access token
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(refreshTokenRequest: RefreshTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(refreshTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.refreshToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Reject a pending change
         * @param {string} pendingChangeId 
         * @param {RejectPendingChangeRequest} rejectPendingChangeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejectPendingChange(pendingChangeId: string, rejectPendingChangeRequest: RejectPendingChangeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectPendingChange(pendingChangeId, rejectPendingChangeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.rejectPendingChange']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove tag from feature
         * @param {string} featureId 
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeFeatureTag(featureId: string, tagId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeFeatureTag(featureId, tagId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.removeFeatureTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Reset/generate secret 2FA (using email-confirmation)
         * @param {TwoFAResetRequest} twoFAResetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reset2FA(twoFAResetRequest: TwoFAResetRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TwoFASetupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reset2FA(twoFAResetRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.reset2FA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Reset password using token
         * @param {ResetPasswordRequest} resetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPassword(resetPasswordRequest: ResetPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetPassword(resetPasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.resetPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Handle SSO callback from Keycloak
         * @param {SSOCallbackRequest} sSOCallbackRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sSOCallback(sSOCallbackRequest: SSOCallbackRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sSOCallback(sSOCallbackRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.sSOCallback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Initiate SSO login flow
         * @param {string} provider Name of the SSO provider to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sSOInitiate(provider: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SSOInitiateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sSOInitiate(provider, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.sSOInitiate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set or unset superuser status (superuser only, cannot modify admin user)
         * @param {number} userId 
         * @param {SetSuperuserStatusRequest} setSuperuserStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSuperuserStatus(userId: number, setSuperuserStatusRequest: SetSuperuserStatusRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSuperuserStatus(userId, setSuperuserStatusRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.setSuperuserStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set or unset user active status (superuser only)
         * @param {number} userId 
         * @param {SetUserActiveStatusRequest} setUserActiveStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setUserActiveStatus(userId: number, setUserActiveStatusRequest: SetUserActiveStatusRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setUserActiveStatus(userId, setUserActiveStatusRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.setUserActiveStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Begin setup 2FA (generate secret and QR-code)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setup2FA(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TwoFASetupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setup2FA(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.setup2FA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Synchronize customized feature rule
         * @param {string} featureId 
         * @param {string} ruleId 
         * @param {string} environmentKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncCustomizedFeatureRule(featureId: string, ruleId: string, environmentKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncCustomizedFeatureRule(featureId, ruleId, environmentKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.syncCustomizedFeatureRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Start user synchronization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncLDAPUsers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LDAPSyncStartResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncLDAPUsers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.syncLDAPUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Test feature timeline with mock schedules
         * @param {string} featureId 
         * @param {string} from Start of the period (inclusive)
         * @param {string} to End of the period (exclusive)
         * @param {string} location Browser\&#39;s location string
         * @param {TestFeatureTimelineRequest} testFeatureTimelineRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testFeatureTimeline(featureId: string, from: string, to: string, location: string, testFeatureTimelineRequest: TestFeatureTimelineRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureTimelineResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testFeatureTimeline(featureId, from, to, location, testFeatureTimelineRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.testFeatureTimeline']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Test LDAP connection
         * @param {LDAPConnectionTest} lDAPConnectionTest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testLDAPConnection(lDAPConnectionTest: LDAPConnectionTest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LDAPConnectionTestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testLDAPConnection(lDAPConnectionTest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.testLDAPConnection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Toggle feature enabled state
         * @param {string} featureId 
         * @param {string} environmentKey 
         * @param {ToggleFeatureRequest} toggleFeatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toggleFeature(featureId: string, environmentKey: string, toggleFeatureRequest: ToggleFeatureRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toggleFeature(featureId, environmentKey, toggleFeatureRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.toggleFeature']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update category
         * @param {string} categoryId 
         * @param {UpdateCategoryRequest} updateCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCategory(categoryId: string, updateCategoryRequest: UpdateCategoryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCategory(categoryId, updateCategoryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update environment
         * @param {number} environmentId 
         * @param {UpdateEnvironmentRequest} updateEnvironmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEnvironment(environmentId: number, updateEnvironmentRequest: UpdateEnvironmentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEnvironment(environmentId, updateEnvironmentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateEnvironment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update feature with rules and variants
         * @param {string} featureId 
         * @param {string} environmentKey 
         * @param {CreateFeatureRequest} createFeatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFeature(featureId: string, environmentKey: string, createFeatureRequest: CreateFeatureRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureDetailsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFeature(featureId, environmentKey, createFeatureRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateFeature']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update feature schedule by ID
         * @param {string} scheduleId 
         * @param {UpdateFeatureScheduleRequest} updateFeatureScheduleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFeatureSchedule(scheduleId: string, updateFeatureScheduleRequest: UpdateFeatureScheduleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureScheduleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFeatureSchedule(scheduleId, updateFeatureScheduleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateFeatureSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create or update LDAP configuration
         * @param {LDAPConfig} lDAPConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLDAPConfig(lDAPConfig: LDAPConfig, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LDAPConfigResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLDAPConfig(lDAPConfig, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateLDAPConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the system license with a new license key
         * @summary Update license
         * @param {UpdateLicenseRequest} updateLicenseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLicense(updateLicenseRequest: UpdateLicenseRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LicenseStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLicense(updateLicenseRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateLicense']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update license acceptance status
         * @param {UpdateLicenseAcceptanceRequest} updateLicenseAcceptanceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLicenseAcceptance(updateLicenseAcceptanceRequest: UpdateLicenseAcceptanceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLicenseAcceptance(updateLicenseAcceptanceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateLicenseAcceptance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update project name and description
         * @param {string} projectId 
         * @param {UpdateProjectRequest} updateProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProject(projectId: string, updateProjectRequest: UpdateProjectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProject(projectId, updateProjectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update project setting
         * @param {string} projectId 
         * @param {string} settingName 
         * @param {UpdateProjectSettingRequest} updateProjectSettingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProjectSetting(projectId: string, settingName: string, updateProjectSettingRequest: UpdateProjectSettingRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectSettingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProjectSetting(projectId, settingName, updateProjectSettingRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateProjectSetting']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update tag
         * @param {string} projectId 
         * @param {string} tagId 
         * @param {UpdateProjectTagRequest} updateProjectTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProjectTag(projectId: string, tagId: string, updateProjectTagRequest: UpdateProjectTagRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectTagResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProjectTag(projectId, tagId, updateProjectTagRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateProjectTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update segment
         * @param {string} segmentId 
         * @param {UpdateSegmentRequest} updateSegmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSegment(segmentId: string, updateSegmentRequest: UpdateSegmentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SegmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSegment(segmentId, updateSegmentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateSegment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Change my password
         * @param {ChangeUserPasswordRequest} changeUserPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userChangeMyPassword(changeUserPasswordRequest: ChangeUserPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userChangeMyPassword(changeUserPasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.userChangeMyPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Verify 2FA-code on login
         * @param {TwoFAVerifyRequest} twoFAVerifyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verify2FA(twoFAVerifyRequest: TwoFAVerifyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TwoFAVerifyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verify2FA(twoFAVerifyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.verify2FA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Add tag to feature
         * @param {string} featureId 
         * @param {AddFeatureTagRequest} addFeatureTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFeatureTag(featureId: string, addFeatureTagRequest: AddFeatureTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addFeatureTag(featureId, addFeatureTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add new project
         * @param {AddProjectRequest} addProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProject(addProjectRequest: AddProjectRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addProject(addProjectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Approve a pending change
         * @param {string} pendingChangeId 
         * @param {ApprovePendingChangeRequest} approvePendingChangeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approvePendingChange(pendingChangeId: string, approvePendingChangeRequest: ApprovePendingChangeRequest, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.approvePendingChange(pendingChangeId, approvePendingChangeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Archive a project
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveProject(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.archiveProject(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancel ongoing synchronization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelLDAPSync(options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.cancelLDAPSync(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancel a pending change
         * @param {string} pendingChangeId 
         * @param {CancelPendingChangeRequest} cancelPendingChangeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPendingChange(pendingChangeId: string, cancelPendingChangeRequest: CancelPendingChangeRequest, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.cancelPendingChange(pendingChangeId, cancelPendingChangeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Approve enable 2FA (code from app)
         * @param {TwoFAConfirmRequest} twoFAConfirmRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirm2FA(twoFAConfirmRequest: TwoFAConfirmRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.confirm2FA(twoFAConfirmRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Finishes the SAML authentication flow.   The Identity Provider sends an HTTP-POST request that contains **SAMLResponse** (mandatory, Base64-encoded `<samlp:Response>` XML) and the optional **RelayState** parameter.   On success the service creates a user session (cookie or JWT) and redirects the browser to the application UI. 
         * @summary Assertion Consumer Service (ACS) endpoint
         * @param {string} sAMLResponse Base64-encoded IdP &#x60;&lt;samlp:Response&gt;&#x60; document
         * @param {string} relayState Value round-tripped from the initial authentication request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumeSAMLAssertion(sAMLResponse: string, relayState: string, options?: RawAxiosRequestConfig): AxiosPromise<Error> {
            return localVarFp.consumeSAMLAssertion(sAMLResponse, relayState, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create new category
         * @param {CreateCategoryRequest} createCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategory(createCategoryRequest: CreateCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<CategoryResponse> {
            return localVarFp.createCategory(createCategoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create environment
         * @param {string} projectId 
         * @param {CreateEnvironmentRequest} createEnvironmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironment(projectId: string, createEnvironmentRequest: CreateEnvironmentRequest, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentResponse> {
            return localVarFp.createEnvironment(projectId, createEnvironmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create flag variant for feature
         * @param {string} featureId 
         * @param {string} environmentKey 
         * @param {CreateFlagVariantRequest} createFlagVariantRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeatureFlagVariant(featureId: string, environmentKey: string, createFlagVariantRequest: CreateFlagVariantRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlagVariantResponse> {
            return localVarFp.createFeatureFlagVariant(featureId, environmentKey, createFlagVariantRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create rule for feature
         * @param {string} featureId 
         * @param {string} environmentKey 
         * @param {CreateRuleRequest} createRuleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeatureRule(featureId: string, environmentKey: string, createRuleRequest: CreateRuleRequest, options?: RawAxiosRequestConfig): AxiosPromise<RuleResponse> {
            return localVarFp.createFeatureRule(featureId, environmentKey, createRuleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create schedule for feature
         * @param {string} featureId 
         * @param {string} environmentKey 
         * @param {CreateFeatureScheduleRequest} createFeatureScheduleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeatureSchedule(featureId: string, environmentKey: string, createFeatureScheduleRequest: CreateFeatureScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<FeatureScheduleResponse> {
            return localVarFp.createFeatureSchedule(featureId, environmentKey, createFeatureScheduleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create feature for project
         * @param {string} projectId 
         * @param {CreateFeatureRequest} createFeatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectFeature(projectId: string, createFeatureRequest: CreateFeatureRequest, options?: RawAxiosRequestConfig): AxiosPromise<FeatureResponse> {
            return localVarFp.createProjectFeature(projectId, createFeatureRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create segment for project
         * @param {string} projectId 
         * @param {CreateSegmentRequest} createSegmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectSegment(projectId: string, createSegmentRequest: CreateSegmentRequest, options?: RawAxiosRequestConfig): AxiosPromise<SegmentResponse> {
            return localVarFp.createProjectSegment(projectId, createSegmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create project setting
         * @param {string} projectId 
         * @param {CreateProjectSettingRequest} createProjectSettingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectSetting(projectId: string, createProjectSettingRequest: CreateProjectSettingRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectSettingResponse> {
            return localVarFp.createProjectSetting(projectId, createProjectSettingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create new tag for project
         * @param {string} projectId 
         * @param {CreateProjectTagRequest} createProjectTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectTag(projectId: string, createProjectTagRequest: CreateProjectTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectTagResponse> {
            return localVarFp.createProjectTag(projectId, createProjectTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create rule attribute
         * @param {CreateRuleAttributeRequest} createRuleAttributeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRuleAttribute(createRuleAttributeRequest: CreateRuleAttributeRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createRuleAttribute(createRuleAttributeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new user (superuser only)
         * @param {CreateUserRequest} createUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(createUserRequest: CreateUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateUserResponse> {
            return localVarFp.createUser(createUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete category
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory(categoryId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCategory(categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete environment
         * @param {number} environmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironment(environmentId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteEnvironment(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete feature
         * @param {string} featureId 
         * @param {string} environmentKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeature(featureId: string, environmentKey: string, options?: RawAxiosRequestConfig): AxiosPromise<PendingChangeResponse> {
            return localVarFp.deleteFeature(featureId, environmentKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete feature schedule by ID
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeatureSchedule(scheduleId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteFeatureSchedule(scheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete LDAP configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLDAPConfig(options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.deleteLDAPConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete project setting
         * @param {string} projectId 
         * @param {string} settingName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectSetting(projectId: string, settingName: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteProjectSetting(projectId, settingName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete tag
         * @param {string} projectId 
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectTag(projectId: string, tagId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteProjectTag(projectId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete rule attribute
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRuleAttribute(name: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRuleAttribute(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete segment
         * @param {string} segmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSegment(segmentId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSegment(segmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a user (superuser only, cannot delete superusers)
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Disable 2FA (using email-confirmation)
         * @param {TwoFADisableRequest} twoFADisableRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disable2FA(twoFADisableRequest: TwoFADisableRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.disable2FA(twoFADisableRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request a password reset
         * @param {ForgotPasswordRequest} forgotPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPassword(forgotPasswordRequest: ForgotPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.forgotPassword(forgotPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get category details
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategory(categoryId: string, options?: RawAxiosRequestConfig): AxiosPromise<CategoryResponse> {
            return localVarFp.getCategory(categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get current user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getCurrentUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get environment
         * @param {number} environmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironment(environmentId: number, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentResponse> {
            return localVarFp.getEnvironment(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get feature with rules and variants
         * @param {string} featureId 
         * @param {string} environmentKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeature(featureId: string, environmentKey: string, options?: RawAxiosRequestConfig): AxiosPromise<FeatureDetailsResponse> {
            return localVarFp.getFeature(featureId, environmentKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get feature schedule by ID
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureSchedule(scheduleId: string, options?: RawAxiosRequestConfig): AxiosPromise<FeatureScheduleResponse> {
            return localVarFp.getFeatureSchedule(scheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get feature timeline within period
         * @param {string} featureId 
         * @param {string} from Start of the period (inclusive)
         * @param {string} to End of the period (exclusive)
         * @param {string} location Browser\&#39;s location string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureTimeline(featureId: string, from: string, to: string, location: string, options?: RawAxiosRequestConfig): AxiosPromise<FeatureTimelineResponse> {
            return localVarFp.getFeatureTimeline(featureId, from, to, location, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get LDAP configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLDAPConfig(options?: RawAxiosRequestConfig): AxiosPromise<LDAPConfig> {
            return localVarFp.getLDAPConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get LDAP statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLDAPStatistics(options?: RawAxiosRequestConfig): AxiosPromise<LDAPStatistics> {
            return localVarFp.getLDAPStatistics(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get synchronization log details
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLDAPSyncLogDetails(id: number, options?: RawAxiosRequestConfig): AxiosPromise<LDAPSyncLogDetails> {
            return localVarFp.getLDAPSyncLogDetails(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get synchronization logs
         * @param {number} [limit] 
         * @param {GetLDAPSyncLogsLevelEnum} [level] 
         * @param {string} [syncId] 
         * @param {string} [username] 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLDAPSyncLogs(limit?: number, level?: GetLDAPSyncLogsLevelEnum, syncId?: string, username?: string, from?: string, to?: string, options?: RawAxiosRequestConfig): AxiosPromise<LDAPSyncLogs> {
            return localVarFp.getLDAPSyncLogs(limit, level, syncId, username, from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get synchronization progress
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLDAPSyncProgress(options?: RawAxiosRequestConfig): AxiosPromise<LDAPSyncProgress> {
            return localVarFp.getLDAPSyncProgress(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get synchronization status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLDAPSyncStatus(options?: RawAxiosRequestConfig): AxiosPromise<LDAPSyncStatus> {
            return localVarFp.getLDAPSyncStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the current license status including validity, expiration date, and type
         * @summary Get license status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicenseStatus(options?: RawAxiosRequestConfig): AxiosPromise<LicenseStatusResponse> {
            return localVarFp.getLicenseStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get pending change by ID
         * @param {string} pendingChangeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPendingChange(pendingChangeId: string, options?: RawAxiosRequestConfig): AxiosPromise<PendingChangeResponse> {
            return localVarFp.getPendingChange(pendingChangeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get product information including client ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductInfo(options?: RawAxiosRequestConfig): AxiosPromise<ProductInfoResponse> {
            return localVarFp.getProductInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get project details
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<ProjectResponse> {
            return localVarFp.getProject(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get project setting by name
         * @param {string} projectId 
         * @param {string} settingName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSetting(projectId: string, settingName: string, options?: RawAxiosRequestConfig): AxiosPromise<ProjectSettingResponse> {
            return localVarFp.getProjectSetting(projectId, settingName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get tag details
         * @param {string} projectId 
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectTag(projectId: string, tagId: string, options?: RawAxiosRequestConfig): AxiosPromise<ProjectTagResponse> {
            return localVarFp.getProjectTag(projectId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get SAML metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSAMLMetadata(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getSAMLMetadata(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get available SSO providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSSOProviders(options?: RawAxiosRequestConfig): AxiosPromise<SSOProvidersResponse> {
            return localVarFp.getSSOProviders(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get segment by ID
         * @param {string} segmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegment(segmentId: string, options?: RawAxiosRequestConfig): AxiosPromise<SegmentResponse> {
            return localVarFp.getSegment(segmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Initiate TOTP approval session
         * @param {string} pendingChangeId 
         * @param {InitiateTOTPApprovalRequest} initiateTOTPApprovalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateTOTPApproval(pendingChangeId: string, initiateTOTPApprovalRequest: InitiateTOTPApprovalRequest, options?: RawAxiosRequestConfig): AxiosPromise<InitiateTOTPApprovalResponse> {
            return localVarFp.initiateTOTPApproval(pendingChangeId, initiateTOTPApprovalRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all feature schedules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllFeatureSchedules(options?: RawAxiosRequestConfig): AxiosPromise<Array<FeatureSchedule>> {
            return localVarFp.listAllFeatureSchedules(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get categories list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCategories(options?: RawAxiosRequestConfig): AxiosPromise<Array<Category>> {
            return localVarFp.listCategories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List flag variants for feature
         * @param {string} featureId 
         * @param {string} environmentKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFeatureFlagVariants(featureId: string, environmentKey: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlagVariant>> {
            return localVarFp.listFeatureFlagVariants(featureId, environmentKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List rules for feature
         * @param {string} featureId 
         * @param {string} environmentKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFeatureRules(featureId: string, environmentKey: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Rule>> {
            return localVarFp.listFeatureRules(featureId, environmentKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List schedules for feature
         * @param {string} featureId 
         * @param {string} environmentKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFeatureSchedules(featureId: string, environmentKey: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<FeatureSchedule>> {
            return localVarFp.listFeatureSchedules(featureId, environmentKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List feature tags
         * @param {string} featureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFeatureTags(featureId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ProjectTag>> {
            return localVarFp.listFeatureTags(featureId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List pending changes
         * @param {number} [environmentId] 
         * @param {string} [projectId] 
         * @param {ListPendingChangesStatusEnum} [status] 
         * @param {number} [userId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {ListPendingChangesSortByEnum} [sortBy] 
         * @param {boolean} [sortDesc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPendingChanges(environmentId?: number, projectId?: string, status?: ListPendingChangesStatusEnum, userId?: number, page?: number, perPage?: number, sortBy?: ListPendingChangesSortByEnum, sortDesc?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<PendingChangesListResponse> {
            return localVarFp.listPendingChanges(environmentId, projectId, status, userId, page, perPage, sortBy, sortDesc, options).then((request) => request(axios, basePath));
        },
        /**
         * Get history of changes made to project features, rules, and other entities grouped by request_id
         * @summary Get project changes history
         * @param {string} projectId Project ID
         * @param {number} [page] Page number (starts from 1)
         * @param {number} [perPage] Items per page
         * @param {ListProjectChangesSortByEnum} [sortBy] Sort by field
         * @param {SortOrder} [sortOrder] Sort order
         * @param {string} [actor] Filter by actor (system, sdk, user:&lt;user_id&gt;)
         * @param {EntityType} [entity] Filter by entity type
         * @param {AuditAction} [action] Filter by action type
         * @param {string} [featureId] Filter by specific feature ID
         * @param {string} [from] Filter changes from this date (ISO 8601 format)
         * @param {string} [to] Filter changes until this date (ISO 8601 format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectChanges(projectId: string, page?: number, perPage?: number, sortBy?: ListProjectChangesSortByEnum, sortOrder?: SortOrder, actor?: string, entity?: EntityType, action?: AuditAction, featureId?: string, from?: string, to?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListChangesResponse> {
            return localVarFp.listProjectChanges(projectId, page, perPage, sortBy, sortOrder, actor, entity, action, featureId, from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List project environments
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectEnvironments(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<ListEnvironmentsResponse> {
            return localVarFp.listProjectEnvironments(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List features for project
         * @param {string} projectId 
         * @param {string} environmentKey Environment key (dev, stage, prod) to filter features
         * @param {ListProjectFeaturesKindEnum} [kind] Filter by feature kind
         * @param {boolean} [enabled] Filter by enabled state
         * @param {string} [textSelector] Case-insensitive text search across key, name, description, rollout_key
         * @param {string} [tagIds] Filter by tag IDs (comma-separated)
         * @param {ListProjectFeaturesSortByEnum} [sortBy] Sort by field
         * @param {SortOrder} [sortOrder] Sort order
         * @param {number} [page] Page number (starts from 1)
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectFeatures(projectId: string, environmentKey: string, kind?: ListProjectFeaturesKindEnum, enabled?: boolean, textSelector?: string, tagIds?: string, sortBy?: ListProjectFeaturesSortByEnum, sortOrder?: SortOrder, page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListFeaturesResponse> {
            return localVarFp.listProjectFeatures(projectId, environmentKey, kind, enabled, textSelector, tagIds, sortBy, sortOrder, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List segments for project
         * @param {string} projectId 
         * @param {string} [textSelector] Case-insensitive text search across name, description
         * @param {ListProjectSegmentsSortByEnum} [sortBy] Sort by field
         * @param {SortOrder} [sortOrder] Sort order
         * @param {number} [page] Page number (starts from 1)
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectSegments(projectId: string, textSelector?: string, sortBy?: ListProjectSegmentsSortByEnum, sortOrder?: SortOrder, page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListSegmentsResponse> {
            return localVarFp.listProjectSegments(projectId, textSelector, sortBy, sortOrder, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List project settings
         * @param {string} projectId 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectSettings(projectId: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListProjectSettingsResponse> {
            return localVarFp.listProjectSettings(projectId, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get tags list for project
         * @param {string} projectId 
         * @param {string} [categoryId] Filter by category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectTags(projectId: string, categoryId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ProjectTag>> {
            return localVarFp.listProjectTags(projectId, categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get projects list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects(options?: RawAxiosRequestConfig): AxiosPromise<Array<Project>> {
            return localVarFp.listProjects(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List of rule attributes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuleAttributes(options?: RawAxiosRequestConfig): AxiosPromise<Array<RuleAttributeEntity>> {
            return localVarFp.listRuleAttributes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get desync feature IDs by segment ID
         * @param {string} segmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSegmentDesyncFeatureIDs(segmentId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.listSegmentDesyncFeatureIDs(segmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all users (superuser only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(options?: RawAxiosRequestConfig): AxiosPromise<Array<User>> {
            return localVarFp.listUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Authenticate user and get access token
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponse> {
            return localVarFp.login(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refresh access token
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(refreshTokenRequest: RefreshTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<RefreshTokenResponse> {
            return localVarFp.refreshToken(refreshTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reject a pending change
         * @param {string} pendingChangeId 
         * @param {RejectPendingChangeRequest} rejectPendingChangeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectPendingChange(pendingChangeId: string, rejectPendingChangeRequest: RejectPendingChangeRequest, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.rejectPendingChange(pendingChangeId, rejectPendingChangeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove tag from feature
         * @param {string} featureId 
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFeatureTag(featureId: string, tagId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeFeatureTag(featureId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset/generate secret 2FA (using email-confirmation)
         * @param {TwoFAResetRequest} twoFAResetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reset2FA(twoFAResetRequest: TwoFAResetRequest, options?: RawAxiosRequestConfig): AxiosPromise<TwoFASetupResponse> {
            return localVarFp.reset2FA(twoFAResetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset password using token
         * @param {ResetPasswordRequest} resetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword(resetPasswordRequest: ResetPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.resetPassword(resetPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Handle SSO callback from Keycloak
         * @param {SSOCallbackRequest} sSOCallbackRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sSOCallback(sSOCallbackRequest: SSOCallbackRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponse> {
            return localVarFp.sSOCallback(sSOCallbackRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Initiate SSO login flow
         * @param {string} provider Name of the SSO provider to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sSOInitiate(provider: string, options?: RawAxiosRequestConfig): AxiosPromise<SSOInitiateResponse> {
            return localVarFp.sSOInitiate(provider, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set or unset superuser status (superuser only, cannot modify admin user)
         * @param {number} userId 
         * @param {SetSuperuserStatusRequest} setSuperuserStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSuperuserStatus(userId: number, setSuperuserStatusRequest: SetSuperuserStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.setSuperuserStatus(userId, setSuperuserStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set or unset user active status (superuser only)
         * @param {number} userId 
         * @param {SetUserActiveStatusRequest} setUserActiveStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserActiveStatus(userId: number, setUserActiveStatusRequest: SetUserActiveStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.setUserActiveStatus(userId, setUserActiveStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Begin setup 2FA (generate secret and QR-code)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setup2FA(options?: RawAxiosRequestConfig): AxiosPromise<TwoFASetupResponse> {
            return localVarFp.setup2FA(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Synchronize customized feature rule
         * @param {string} featureId 
         * @param {string} ruleId 
         * @param {string} environmentKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncCustomizedFeatureRule(featureId: string, ruleId: string, environmentKey: string, options?: RawAxiosRequestConfig): AxiosPromise<RuleResponse> {
            return localVarFp.syncCustomizedFeatureRule(featureId, ruleId, environmentKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start user synchronization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncLDAPUsers(options?: RawAxiosRequestConfig): AxiosPromise<LDAPSyncStartResponse> {
            return localVarFp.syncLDAPUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Test feature timeline with mock schedules
         * @param {string} featureId 
         * @param {string} from Start of the period (inclusive)
         * @param {string} to End of the period (exclusive)
         * @param {string} location Browser\&#39;s location string
         * @param {TestFeatureTimelineRequest} testFeatureTimelineRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testFeatureTimeline(featureId: string, from: string, to: string, location: string, testFeatureTimelineRequest: TestFeatureTimelineRequest, options?: RawAxiosRequestConfig): AxiosPromise<FeatureTimelineResponse> {
            return localVarFp.testFeatureTimeline(featureId, from, to, location, testFeatureTimelineRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Test LDAP connection
         * @param {LDAPConnectionTest} lDAPConnectionTest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testLDAPConnection(lDAPConnectionTest: LDAPConnectionTest, options?: RawAxiosRequestConfig): AxiosPromise<LDAPConnectionTestResponse> {
            return localVarFp.testLDAPConnection(lDAPConnectionTest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Toggle feature enabled state
         * @param {string} featureId 
         * @param {string} environmentKey 
         * @param {ToggleFeatureRequest} toggleFeatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleFeature(featureId: string, environmentKey: string, toggleFeatureRequest: ToggleFeatureRequest, options?: RawAxiosRequestConfig): AxiosPromise<FeatureResponse> {
            return localVarFp.toggleFeature(featureId, environmentKey, toggleFeatureRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update category
         * @param {string} categoryId 
         * @param {UpdateCategoryRequest} updateCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory(categoryId: string, updateCategoryRequest: UpdateCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<CategoryResponse> {
            return localVarFp.updateCategory(categoryId, updateCategoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update environment
         * @param {number} environmentId 
         * @param {UpdateEnvironmentRequest} updateEnvironmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEnvironment(environmentId: number, updateEnvironmentRequest: UpdateEnvironmentRequest, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentResponse> {
            return localVarFp.updateEnvironment(environmentId, updateEnvironmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update feature with rules and variants
         * @param {string} featureId 
         * @param {string} environmentKey 
         * @param {CreateFeatureRequest} createFeatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeature(featureId: string, environmentKey: string, createFeatureRequest: CreateFeatureRequest, options?: RawAxiosRequestConfig): AxiosPromise<FeatureDetailsResponse> {
            return localVarFp.updateFeature(featureId, environmentKey, createFeatureRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update feature schedule by ID
         * @param {string} scheduleId 
         * @param {UpdateFeatureScheduleRequest} updateFeatureScheduleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeatureSchedule(scheduleId: string, updateFeatureScheduleRequest: UpdateFeatureScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<FeatureScheduleResponse> {
            return localVarFp.updateFeatureSchedule(scheduleId, updateFeatureScheduleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create or update LDAP configuration
         * @param {LDAPConfig} lDAPConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLDAPConfig(lDAPConfig: LDAPConfig, options?: RawAxiosRequestConfig): AxiosPromise<LDAPConfigResponse> {
            return localVarFp.updateLDAPConfig(lDAPConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the system license with a new license key
         * @summary Update license
         * @param {UpdateLicenseRequest} updateLicenseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLicense(updateLicenseRequest: UpdateLicenseRequest, options?: RawAxiosRequestConfig): AxiosPromise<LicenseStatusResponse> {
            return localVarFp.updateLicense(updateLicenseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update license acceptance status
         * @param {UpdateLicenseAcceptanceRequest} updateLicenseAcceptanceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLicenseAcceptance(updateLicenseAcceptanceRequest: UpdateLicenseAcceptanceRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateLicenseAcceptance(updateLicenseAcceptanceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update project name and description
         * @param {string} projectId 
         * @param {UpdateProjectRequest} updateProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject(projectId: string, updateProjectRequest: UpdateProjectRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectResponse> {
            return localVarFp.updateProject(projectId, updateProjectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update project setting
         * @param {string} projectId 
         * @param {string} settingName 
         * @param {UpdateProjectSettingRequest} updateProjectSettingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectSetting(projectId: string, settingName: string, updateProjectSettingRequest: UpdateProjectSettingRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectSettingResponse> {
            return localVarFp.updateProjectSetting(projectId, settingName, updateProjectSettingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update tag
         * @param {string} projectId 
         * @param {string} tagId 
         * @param {UpdateProjectTagRequest} updateProjectTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectTag(projectId: string, tagId: string, updateProjectTagRequest: UpdateProjectTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectTagResponse> {
            return localVarFp.updateProjectTag(projectId, tagId, updateProjectTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update segment
         * @param {string} segmentId 
         * @param {UpdateSegmentRequest} updateSegmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSegment(segmentId: string, updateSegmentRequest: UpdateSegmentRequest, options?: RawAxiosRequestConfig): AxiosPromise<SegmentResponse> {
            return localVarFp.updateSegment(segmentId, updateSegmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Change my password
         * @param {ChangeUserPasswordRequest} changeUserPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userChangeMyPassword(changeUserPasswordRequest: ChangeUserPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.userChangeMyPassword(changeUserPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Verify 2FA-code on login
         * @param {TwoFAVerifyRequest} twoFAVerifyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verify2FA(twoFAVerifyRequest: TwoFAVerifyRequest, options?: RawAxiosRequestConfig): AxiosPromise<TwoFAVerifyResponse> {
            return localVarFp.verify2FA(twoFAVerifyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Add tag to feature
     * @param {string} featureId 
     * @param {AddFeatureTagRequest} addFeatureTagRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addFeatureTag(featureId: string, addFeatureTagRequest: AddFeatureTagRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).addFeatureTag(featureId, addFeatureTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add new project
     * @param {AddProjectRequest} addProjectRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addProject(addProjectRequest: AddProjectRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).addProject(addProjectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Approve a pending change
     * @param {string} pendingChangeId 
     * @param {ApprovePendingChangeRequest} approvePendingChangeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public approvePendingChange(pendingChangeId: string, approvePendingChangeRequest: ApprovePendingChangeRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).approvePendingChange(pendingChangeId, approvePendingChangeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Archive a project
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public archiveProject(projectId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).archiveProject(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancel ongoing synchronization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cancelLDAPSync(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).cancelLDAPSync(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancel a pending change
     * @param {string} pendingChangeId 
     * @param {CancelPendingChangeRequest} cancelPendingChangeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cancelPendingChange(pendingChangeId: string, cancelPendingChangeRequest: CancelPendingChangeRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).cancelPendingChange(pendingChangeId, cancelPendingChangeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Approve enable 2FA (code from app)
     * @param {TwoFAConfirmRequest} twoFAConfirmRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public confirm2FA(twoFAConfirmRequest: TwoFAConfirmRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).confirm2FA(twoFAConfirmRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Finishes the SAML authentication flow.   The Identity Provider sends an HTTP-POST request that contains **SAMLResponse** (mandatory, Base64-encoded `<samlp:Response>` XML) and the optional **RelayState** parameter.   On success the service creates a user session (cookie or JWT) and redirects the browser to the application UI. 
     * @summary Assertion Consumer Service (ACS) endpoint
     * @param {string} sAMLResponse Base64-encoded IdP &#x60;&lt;samlp:Response&gt;&#x60; document
     * @param {string} relayState Value round-tripped from the initial authentication request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public consumeSAMLAssertion(sAMLResponse: string, relayState: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).consumeSAMLAssertion(sAMLResponse, relayState, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create new category
     * @param {CreateCategoryRequest} createCategoryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createCategory(createCategoryRequest: CreateCategoryRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createCategory(createCategoryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create environment
     * @param {string} projectId 
     * @param {CreateEnvironmentRequest} createEnvironmentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createEnvironment(projectId: string, createEnvironmentRequest: CreateEnvironmentRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createEnvironment(projectId, createEnvironmentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create flag variant for feature
     * @param {string} featureId 
     * @param {string} environmentKey 
     * @param {CreateFlagVariantRequest} createFlagVariantRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createFeatureFlagVariant(featureId: string, environmentKey: string, createFlagVariantRequest: CreateFlagVariantRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createFeatureFlagVariant(featureId, environmentKey, createFlagVariantRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create rule for feature
     * @param {string} featureId 
     * @param {string} environmentKey 
     * @param {CreateRuleRequest} createRuleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createFeatureRule(featureId: string, environmentKey: string, createRuleRequest: CreateRuleRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createFeatureRule(featureId, environmentKey, createRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create schedule for feature
     * @param {string} featureId 
     * @param {string} environmentKey 
     * @param {CreateFeatureScheduleRequest} createFeatureScheduleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createFeatureSchedule(featureId: string, environmentKey: string, createFeatureScheduleRequest: CreateFeatureScheduleRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createFeatureSchedule(featureId, environmentKey, createFeatureScheduleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create feature for project
     * @param {string} projectId 
     * @param {CreateFeatureRequest} createFeatureRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createProjectFeature(projectId: string, createFeatureRequest: CreateFeatureRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createProjectFeature(projectId, createFeatureRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create segment for project
     * @param {string} projectId 
     * @param {CreateSegmentRequest} createSegmentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createProjectSegment(projectId: string, createSegmentRequest: CreateSegmentRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createProjectSegment(projectId, createSegmentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create project setting
     * @param {string} projectId 
     * @param {CreateProjectSettingRequest} createProjectSettingRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createProjectSetting(projectId: string, createProjectSettingRequest: CreateProjectSettingRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createProjectSetting(projectId, createProjectSettingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create new tag for project
     * @param {string} projectId 
     * @param {CreateProjectTagRequest} createProjectTagRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createProjectTag(projectId: string, createProjectTagRequest: CreateProjectTagRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createProjectTag(projectId, createProjectTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create rule attribute
     * @param {CreateRuleAttributeRequest} createRuleAttributeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createRuleAttribute(createRuleAttributeRequest: CreateRuleAttributeRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createRuleAttribute(createRuleAttributeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new user (superuser only)
     * @param {CreateUserRequest} createUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createUser(createUserRequest: CreateUserRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createUser(createUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete category
     * @param {string} categoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteCategory(categoryId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteCategory(categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete environment
     * @param {number} environmentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteEnvironment(environmentId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteEnvironment(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete feature
     * @param {string} featureId 
     * @param {string} environmentKey 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteFeature(featureId: string, environmentKey: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteFeature(featureId, environmentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete feature schedule by ID
     * @param {string} scheduleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteFeatureSchedule(scheduleId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteFeatureSchedule(scheduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete LDAP configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteLDAPConfig(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteLDAPConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete project setting
     * @param {string} projectId 
     * @param {string} settingName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteProjectSetting(projectId: string, settingName: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteProjectSetting(projectId, settingName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete tag
     * @param {string} projectId 
     * @param {string} tagId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteProjectTag(projectId: string, tagId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteProjectTag(projectId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete rule attribute
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteRuleAttribute(name: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteRuleAttribute(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete segment
     * @param {string} segmentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteSegment(segmentId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteSegment(segmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a user (superuser only, cannot delete superusers)
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteUser(userId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Disable 2FA (using email-confirmation)
     * @param {TwoFADisableRequest} twoFADisableRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public disable2FA(twoFADisableRequest: TwoFADisableRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).disable2FA(twoFADisableRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request a password reset
     * @param {ForgotPasswordRequest} forgotPasswordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public forgotPassword(forgotPasswordRequest: ForgotPasswordRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).forgotPassword(forgotPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get category details
     * @param {string} categoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCategory(categoryId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCategory(categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get current user information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCurrentUser(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get environment
     * @param {number} environmentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getEnvironment(environmentId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getEnvironment(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get feature with rules and variants
     * @param {string} featureId 
     * @param {string} environmentKey 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFeature(featureId: string, environmentKey: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getFeature(featureId, environmentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get feature schedule by ID
     * @param {string} scheduleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFeatureSchedule(scheduleId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getFeatureSchedule(scheduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get feature timeline within period
     * @param {string} featureId 
     * @param {string} from Start of the period (inclusive)
     * @param {string} to End of the period (exclusive)
     * @param {string} location Browser\&#39;s location string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFeatureTimeline(featureId: string, from: string, to: string, location: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getFeatureTimeline(featureId, from, to, location, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get LDAP configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getLDAPConfig(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLDAPConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get LDAP statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getLDAPStatistics(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLDAPStatistics(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get synchronization log details
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getLDAPSyncLogDetails(id: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLDAPSyncLogDetails(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get synchronization logs
     * @param {number} [limit] 
     * @param {GetLDAPSyncLogsLevelEnum} [level] 
     * @param {string} [syncId] 
     * @param {string} [username] 
     * @param {string} [from] 
     * @param {string} [to] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getLDAPSyncLogs(limit?: number, level?: GetLDAPSyncLogsLevelEnum, syncId?: string, username?: string, from?: string, to?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLDAPSyncLogs(limit, level, syncId, username, from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get synchronization progress
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getLDAPSyncProgress(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLDAPSyncProgress(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get synchronization status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getLDAPSyncStatus(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLDAPSyncStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the current license status including validity, expiration date, and type
     * @summary Get license status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getLicenseStatus(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLicenseStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get pending change by ID
     * @param {string} pendingChangeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPendingChange(pendingChangeId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPendingChange(pendingChangeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get product information including client ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getProductInfo(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getProductInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get project details
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getProject(projectId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getProject(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get project setting by name
     * @param {string} projectId 
     * @param {string} settingName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getProjectSetting(projectId: string, settingName: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getProjectSetting(projectId, settingName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get tag details
     * @param {string} projectId 
     * @param {string} tagId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getProjectTag(projectId: string, tagId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getProjectTag(projectId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get SAML metadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSAMLMetadata(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSAMLMetadata(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get available SSO providers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSSOProviders(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSSOProviders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get segment by ID
     * @param {string} segmentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSegment(segmentId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSegment(segmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Initiate TOTP approval session
     * @param {string} pendingChangeId 
     * @param {InitiateTOTPApprovalRequest} initiateTOTPApprovalRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public initiateTOTPApproval(pendingChangeId: string, initiateTOTPApprovalRequest: InitiateTOTPApprovalRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).initiateTOTPApproval(pendingChangeId, initiateTOTPApprovalRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all feature schedules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listAllFeatureSchedules(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listAllFeatureSchedules(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get categories list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listCategories(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listCategories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List flag variants for feature
     * @param {string} featureId 
     * @param {string} environmentKey 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listFeatureFlagVariants(featureId: string, environmentKey: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listFeatureFlagVariants(featureId, environmentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List rules for feature
     * @param {string} featureId 
     * @param {string} environmentKey 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listFeatureRules(featureId: string, environmentKey: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listFeatureRules(featureId, environmentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List schedules for feature
     * @param {string} featureId 
     * @param {string} environmentKey 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listFeatureSchedules(featureId: string, environmentKey: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listFeatureSchedules(featureId, environmentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List feature tags
     * @param {string} featureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listFeatureTags(featureId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listFeatureTags(featureId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List pending changes
     * @param {number} [environmentId] 
     * @param {string} [projectId] 
     * @param {ListPendingChangesStatusEnum} [status] 
     * @param {number} [userId] 
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {ListPendingChangesSortByEnum} [sortBy] 
     * @param {boolean} [sortDesc] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listPendingChanges(environmentId?: number, projectId?: string, status?: ListPendingChangesStatusEnum, userId?: number, page?: number, perPage?: number, sortBy?: ListPendingChangesSortByEnum, sortDesc?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listPendingChanges(environmentId, projectId, status, userId, page, perPage, sortBy, sortDesc, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get history of changes made to project features, rules, and other entities grouped by request_id
     * @summary Get project changes history
     * @param {string} projectId Project ID
     * @param {number} [page] Page number (starts from 1)
     * @param {number} [perPage] Items per page
     * @param {ListProjectChangesSortByEnum} [sortBy] Sort by field
     * @param {SortOrder} [sortOrder] Sort order
     * @param {string} [actor] Filter by actor (system, sdk, user:&lt;user_id&gt;)
     * @param {EntityType} [entity] Filter by entity type
     * @param {AuditAction} [action] Filter by action type
     * @param {string} [featureId] Filter by specific feature ID
     * @param {string} [from] Filter changes from this date (ISO 8601 format)
     * @param {string} [to] Filter changes until this date (ISO 8601 format)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listProjectChanges(projectId: string, page?: number, perPage?: number, sortBy?: ListProjectChangesSortByEnum, sortOrder?: SortOrder, actor?: string, entity?: EntityType, action?: AuditAction, featureId?: string, from?: string, to?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listProjectChanges(projectId, page, perPage, sortBy, sortOrder, actor, entity, action, featureId, from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List project environments
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listProjectEnvironments(projectId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listProjectEnvironments(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List features for project
     * @param {string} projectId 
     * @param {string} environmentKey Environment key (dev, stage, prod) to filter features
     * @param {ListProjectFeaturesKindEnum} [kind] Filter by feature kind
     * @param {boolean} [enabled] Filter by enabled state
     * @param {string} [textSelector] Case-insensitive text search across key, name, description, rollout_key
     * @param {string} [tagIds] Filter by tag IDs (comma-separated)
     * @param {ListProjectFeaturesSortByEnum} [sortBy] Sort by field
     * @param {SortOrder} [sortOrder] Sort order
     * @param {number} [page] Page number (starts from 1)
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listProjectFeatures(projectId: string, environmentKey: string, kind?: ListProjectFeaturesKindEnum, enabled?: boolean, textSelector?: string, tagIds?: string, sortBy?: ListProjectFeaturesSortByEnum, sortOrder?: SortOrder, page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listProjectFeatures(projectId, environmentKey, kind, enabled, textSelector, tagIds, sortBy, sortOrder, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List segments for project
     * @param {string} projectId 
     * @param {string} [textSelector] Case-insensitive text search across name, description
     * @param {ListProjectSegmentsSortByEnum} [sortBy] Sort by field
     * @param {SortOrder} [sortOrder] Sort order
     * @param {number} [page] Page number (starts from 1)
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listProjectSegments(projectId: string, textSelector?: string, sortBy?: ListProjectSegmentsSortByEnum, sortOrder?: SortOrder, page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listProjectSegments(projectId, textSelector, sortBy, sortOrder, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List project settings
     * @param {string} projectId 
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listProjectSettings(projectId: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listProjectSettings(projectId, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get tags list for project
     * @param {string} projectId 
     * @param {string} [categoryId] Filter by category ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listProjectTags(projectId: string, categoryId?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listProjectTags(projectId, categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get projects list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listProjects(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listProjects(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List of rule attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listRuleAttributes(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listRuleAttributes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get desync feature IDs by segment ID
     * @param {string} segmentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listSegmentDesyncFeatureIDs(segmentId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listSegmentDesyncFeatureIDs(segmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all users (superuser only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listUsers(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Authenticate user and get access token
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).login(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refresh access token
     * @param {RefreshTokenRequest} refreshTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public refreshToken(refreshTokenRequest: RefreshTokenRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).refreshToken(refreshTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reject a pending change
     * @param {string} pendingChangeId 
     * @param {RejectPendingChangeRequest} rejectPendingChangeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rejectPendingChange(pendingChangeId: string, rejectPendingChangeRequest: RejectPendingChangeRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rejectPendingChange(pendingChangeId, rejectPendingChangeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove tag from feature
     * @param {string} featureId 
     * @param {string} tagId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public removeFeatureTag(featureId: string, tagId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).removeFeatureTag(featureId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset/generate secret 2FA (using email-confirmation)
     * @param {TwoFAResetRequest} twoFAResetRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public reset2FA(twoFAResetRequest: TwoFAResetRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).reset2FA(twoFAResetRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset password using token
     * @param {ResetPasswordRequest} resetPasswordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public resetPassword(resetPasswordRequest: ResetPasswordRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).resetPassword(resetPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Handle SSO callback from Keycloak
     * @param {SSOCallbackRequest} sSOCallbackRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public sSOCallback(sSOCallbackRequest: SSOCallbackRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).sSOCallback(sSOCallbackRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Initiate SSO login flow
     * @param {string} provider Name of the SSO provider to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public sSOInitiate(provider: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).sSOInitiate(provider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set or unset superuser status (superuser only, cannot modify admin user)
     * @param {number} userId 
     * @param {SetSuperuserStatusRequest} setSuperuserStatusRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public setSuperuserStatus(userId: number, setSuperuserStatusRequest: SetSuperuserStatusRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).setSuperuserStatus(userId, setSuperuserStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set or unset user active status (superuser only)
     * @param {number} userId 
     * @param {SetUserActiveStatusRequest} setUserActiveStatusRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public setUserActiveStatus(userId: number, setUserActiveStatusRequest: SetUserActiveStatusRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).setUserActiveStatus(userId, setUserActiveStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Begin setup 2FA (generate secret and QR-code)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public setup2FA(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).setup2FA(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Synchronize customized feature rule
     * @param {string} featureId 
     * @param {string} ruleId 
     * @param {string} environmentKey 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public syncCustomizedFeatureRule(featureId: string, ruleId: string, environmentKey: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).syncCustomizedFeatureRule(featureId, ruleId, environmentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start user synchronization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public syncLDAPUsers(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).syncLDAPUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Test feature timeline with mock schedules
     * @param {string} featureId 
     * @param {string} from Start of the period (inclusive)
     * @param {string} to End of the period (exclusive)
     * @param {string} location Browser\&#39;s location string
     * @param {TestFeatureTimelineRequest} testFeatureTimelineRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public testFeatureTimeline(featureId: string, from: string, to: string, location: string, testFeatureTimelineRequest: TestFeatureTimelineRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).testFeatureTimeline(featureId, from, to, location, testFeatureTimelineRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Test LDAP connection
     * @param {LDAPConnectionTest} lDAPConnectionTest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public testLDAPConnection(lDAPConnectionTest: LDAPConnectionTest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).testLDAPConnection(lDAPConnectionTest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Toggle feature enabled state
     * @param {string} featureId 
     * @param {string} environmentKey 
     * @param {ToggleFeatureRequest} toggleFeatureRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public toggleFeature(featureId: string, environmentKey: string, toggleFeatureRequest: ToggleFeatureRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).toggleFeature(featureId, environmentKey, toggleFeatureRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update category
     * @param {string} categoryId 
     * @param {UpdateCategoryRequest} updateCategoryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateCategory(categoryId: string, updateCategoryRequest: UpdateCategoryRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateCategory(categoryId, updateCategoryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update environment
     * @param {number} environmentId 
     * @param {UpdateEnvironmentRequest} updateEnvironmentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateEnvironment(environmentId: number, updateEnvironmentRequest: UpdateEnvironmentRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateEnvironment(environmentId, updateEnvironmentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update feature with rules and variants
     * @param {string} featureId 
     * @param {string} environmentKey 
     * @param {CreateFeatureRequest} createFeatureRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateFeature(featureId: string, environmentKey: string, createFeatureRequest: CreateFeatureRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateFeature(featureId, environmentKey, createFeatureRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update feature schedule by ID
     * @param {string} scheduleId 
     * @param {UpdateFeatureScheduleRequest} updateFeatureScheduleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateFeatureSchedule(scheduleId: string, updateFeatureScheduleRequest: UpdateFeatureScheduleRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateFeatureSchedule(scheduleId, updateFeatureScheduleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create or update LDAP configuration
     * @param {LDAPConfig} lDAPConfig 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateLDAPConfig(lDAPConfig: LDAPConfig, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateLDAPConfig(lDAPConfig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the system license with a new license key
     * @summary Update license
     * @param {UpdateLicenseRequest} updateLicenseRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateLicense(updateLicenseRequest: UpdateLicenseRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateLicense(updateLicenseRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update license acceptance status
     * @param {UpdateLicenseAcceptanceRequest} updateLicenseAcceptanceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateLicenseAcceptance(updateLicenseAcceptanceRequest: UpdateLicenseAcceptanceRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateLicenseAcceptance(updateLicenseAcceptanceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update project name and description
     * @param {string} projectId 
     * @param {UpdateProjectRequest} updateProjectRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateProject(projectId: string, updateProjectRequest: UpdateProjectRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateProject(projectId, updateProjectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update project setting
     * @param {string} projectId 
     * @param {string} settingName 
     * @param {UpdateProjectSettingRequest} updateProjectSettingRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateProjectSetting(projectId: string, settingName: string, updateProjectSettingRequest: UpdateProjectSettingRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateProjectSetting(projectId, settingName, updateProjectSettingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update tag
     * @param {string} projectId 
     * @param {string} tagId 
     * @param {UpdateProjectTagRequest} updateProjectTagRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateProjectTag(projectId: string, tagId: string, updateProjectTagRequest: UpdateProjectTagRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateProjectTag(projectId, tagId, updateProjectTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update segment
     * @param {string} segmentId 
     * @param {UpdateSegmentRequest} updateSegmentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateSegment(segmentId: string, updateSegmentRequest: UpdateSegmentRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateSegment(segmentId, updateSegmentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Change my password
     * @param {ChangeUserPasswordRequest} changeUserPasswordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public userChangeMyPassword(changeUserPasswordRequest: ChangeUserPasswordRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).userChangeMyPassword(changeUserPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Verify 2FA-code on login
     * @param {TwoFAVerifyRequest} twoFAVerifyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public verify2FA(twoFAVerifyRequest: TwoFAVerifyRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).verify2FA(twoFAVerifyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetLDAPSyncLogsLevelEnum = {
    Info: 'info',
    Warning: 'warning',
    Error: 'error'
} as const;
export type GetLDAPSyncLogsLevelEnum = typeof GetLDAPSyncLogsLevelEnum[keyof typeof GetLDAPSyncLogsLevelEnum];
export const ListPendingChangesStatusEnum = {
    Pending: 'pending',
    Approved: 'approved',
    Rejected: 'rejected',
    Cancelled: 'cancelled'
} as const;
export type ListPendingChangesStatusEnum = typeof ListPendingChangesStatusEnum[keyof typeof ListPendingChangesStatusEnum];
export const ListPendingChangesSortByEnum = {
    CreatedAt: 'created_at',
    Status: 'status',
    RequestedBy: 'requested_by'
} as const;
export type ListPendingChangesSortByEnum = typeof ListPendingChangesSortByEnum[keyof typeof ListPendingChangesSortByEnum];
export const ListProjectChangesSortByEnum = {
    CreatedAt: 'created_at',
    Actor: 'actor',
    Entity: 'entity'
} as const;
export type ListProjectChangesSortByEnum = typeof ListProjectChangesSortByEnum[keyof typeof ListProjectChangesSortByEnum];
export const ListProjectFeaturesKindEnum = {
    Simple: 'simple',
    Multivariant: 'multivariant'
} as const;
export type ListProjectFeaturesKindEnum = typeof ListProjectFeaturesKindEnum[keyof typeof ListProjectFeaturesKindEnum];
export const ListProjectFeaturesSortByEnum = {
    Name: 'name',
    Key: 'key',
    Enabled: 'enabled',
    Kind: 'kind',
    CreatedAt: 'created_at',
    UpdatedAt: 'updated_at'
} as const;
export type ListProjectFeaturesSortByEnum = typeof ListProjectFeaturesSortByEnum[keyof typeof ListProjectFeaturesSortByEnum];
export const ListProjectSegmentsSortByEnum = {
    Name: 'name',
    CreatedAt: 'created_at',
    UpdatedAt: 'updated_at'
} as const;
export type ListProjectSegmentsSortByEnum = typeof ListProjectSegmentsSortByEnum[keyof typeof ListProjectSegmentsSortByEnum];


/**
 * UsersApi - axios parameter creator
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Send 2FA email code for disable/reset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        send2FACode: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/me/2fa/send_code`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Send 2FA email code for disable/reset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async send2FACode(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.send2FACode(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.send2FACode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Send 2FA email code for disable/reset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        send2FACode(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.send2FACode(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Send 2FA email code for disable/reset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public send2FACode(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).send2FACode(options).then((request) => request(this.axios, this.basePath));
    }
}



