/* tslint:disable */
/* eslint-disable */
/**
 * Backend API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface AddProjectRequest {
    'name': string;
    'description': string;
}
export interface ChangeUserPasswordRequest {
    'old_password': string;
    'new_password': string;
}
export interface CreateFeatureRequest {
    'key': string;
    'name': string;
    'description'?: string;
    'kind': FeatureKind;
    'default_variant': string;
    'enabled'?: boolean;
    'rollout_key'?: string;
    /**
     * Optional list of flag variants to create along with the feature
     */
    'variants'?: Array<CreateFlagVariantInline>;
    /**
     * Optional list of rules to create along with the feature
     */
    'rules'?: Array<CreateRuleInline>;
}


export interface CreateFeatureScheduleRequest {
    'starts_at'?: string;
    'ends_at'?: string;
    'cron_expr'?: string;
    'timezone': string;
    'action': FeatureScheduleAction;
}


export interface CreateFlagVariantInline {
    /**
     * Client-provided UUID for the variant
     */
    'id': string;
    'name': string;
    'rollout_percent': number;
}
export interface CreateFlagVariantRequest {
    'name': string;
    'rollout_percent': number;
}
export interface CreateRuleAttributeRequest {
    'name': string;
    'description'?: string;
}
export interface CreateRuleInline {
    /**
     * Client-provided UUID for the rule
     */
    'id': string;
    'conditions': RuleConditionExpression;
    'segment_id'?: string;
    'is_customized': boolean;
    'action': RuleAction;
    'flag_variant_id'?: string;
    'priority'?: number;
}


export interface CreateRuleRequest {
    'conditions': RuleConditionExpression;
    'segment_id'?: string;
    'is_customized': boolean;
    'action': RuleAction;
    'flag_variant_id'?: string;
    'priority'?: number;
}


export interface CreateSegmentRequest {
    'name': string;
    'description'?: string;
    'conditions': RuleConditionExpression;
}
export interface CreateUserRequest {
    'username': string;
    'email': string;
    'password': string;
    'is_superuser'?: boolean;
}
export interface CreateUserResponse {
    'user': User;
}
export interface Error2FARequired {
    'error': Error2FARequiredError;
}
export interface Error2FARequiredError {
    'code': string;
    'session_id': string;
    'message': string;
}
export interface ErrorBadRequest {
    'error': ErrorError;
}
export interface ErrorError {
    'message'?: string;
}
export interface ErrorInternalServerError {
    'error': ErrorError;
}
export interface ErrorInvalidCredentials {
    'error': ErrorError;
}
export interface ErrorInvalidToken {
    'error': ErrorError;
}
export interface ErrorNotFound {
    'error': ErrorError;
}
export interface ErrorPermissionDenied {
    'error': ErrorError;
}
export interface ErrorTooManyRequests {
    'error': ErrorError;
}
export interface ErrorUnauthorized {
    'error': ErrorError;
}
export interface Feature {
    'id': string;
    'project_id': string;
    'key': string;
    'name': string;
    'description'?: string;
    'kind': FeatureKind;
    'default_variant': string;
    'enabled': boolean;
    'rollout_key'?: string;
    'created_at': string;
    'updated_at': string;
}


export interface FeatureDetailsResponse {
    'feature': Feature;
    'variants': Array<FlagVariant>;
    'rules': Array<Rule>;
}

export const FeatureKind = {
    Simple: 'simple',
    Multivariant: 'multivariant'
} as const;

export type FeatureKind = typeof FeatureKind[keyof typeof FeatureKind];


export interface FeatureResponse {
    'feature': Feature;
}
export interface FeatureSchedule {
    'id': string;
    'project_id': string;
    'feature_id': string;
    'starts_at'?: string;
    'ends_at'?: string;
    'cron_expr'?: string;
    'timezone': string;
    'action': FeatureScheduleAction;
    'created_at': string;
}


/**
 * Action to apply on schedule
 */

export const FeatureScheduleAction = {
    Enable: 'enable',
    Disable: 'disable'
} as const;

export type FeatureScheduleAction = typeof FeatureScheduleAction[keyof typeof FeatureScheduleAction];


export interface FeatureScheduleResponse {
    'schedule': FeatureSchedule;
}
export interface FlagVariant {
    'id': string;
    'feature_id': string;
    'name': string;
    'rollout_percent': number;
}
export interface FlagVariantResponse {
    'flag_variant': FlagVariant;
}
export interface ForgotPasswordRequest {
    'email': string;
}
export interface LDAPConfig {
    /**
     * Whether LDAP integration is enabled
     */
    'enabled': boolean;
    /**
     * LDAP server URL
     */
    'url': string;
    /**
     * DN for binding to LDAP server
     */
    'bind_dn': string;
    /**
     * Password for binding to LDAP server
     */
    'bind_password': string;
    /**
     * Base DN for user search
     */
    'user_base_dn': string;
    /**
     * Filter for user search
     */
    'user_filter': string;
    /**
     * Attribute for username
     */
    'user_name_attr': string;
    /**
     * Attribute for user email
     */
    'user_email_attr': string;
    /**
     * Whether to use StartTLS
     */
    'start_tls': boolean;
    /**
     * Whether to skip TLS certificate verification
     */
    'insecure_tls': boolean;
    /**
     * Connection timeout
     */
    'timeout': string;
    /**
     * Background synchronization interval
     */
    'sync_interval': number;
}
export interface LDAPConfigResponse {
    'message'?: string;
    'config'?: LDAPConfig;
}
export interface LDAPConnectionTest {
    /**
     * LDAP server URL
     */
    'url': string;
    /**
     * DN for binding to LDAP server
     */
    'bind_dn': string;
    /**
     * Password for binding to LDAP server
     */
    'bind_password': string;
    /**
     * Base DN for user search
     */
    'user_base_dn'?: string;
    /**
     * Filter for user search
     */
    'user_filter'?: string;
    /**
     * Attribute for username
     */
    'user_name_attr'?: string;
    /**
     * Whether to use StartTLS
     */
    'start_tls'?: boolean;
    /**
     * Whether to skip TLS certificate verification
     */
    'insecure_tls'?: boolean;
    /**
     * Connection timeout
     */
    'timeout'?: string;
}
export interface LDAPConnectionTestResponse {
    'success'?: boolean;
    'message'?: string;
    'details'?: LDAPConnectionTestResponseDetails;
}
export interface LDAPConnectionTestResponseDetails {
    'server_info'?: string;
    'user_count'?: number;
    'test_user'?: string;
}
export interface LDAPStatistics {
    'ldap_users'?: number;
    'local_users'?: number;
    'active_users'?: number;
    'inactive_users'?: number;
    'sync_history'?: Array<LDAPStatisticsSyncHistoryInner>;
    'sync_success_rate'?: number;
}
export interface LDAPStatisticsSyncHistoryInner {
    'date'?: string;
    'users_synced'?: number;
    'errors'?: number;
    'duration_minutes'?: number;
}
export interface LDAPSyncLogDetails {
    'id': number;
    'timestamp': string;
    'level': LDAPSyncLogDetailsLevelEnum;
    'message': string;
    'username'?: string;
    'details'?: string;
    'sync_session_id': string;
    'stack_trace'?: string;
    'ldap_error_code'?: number;
    'ldap_error_message'?: string;
}

export const LDAPSyncLogDetailsLevelEnum = {
    Info: 'info',
    Warning: 'warning',
    Error: 'error'
} as const;

export type LDAPSyncLogDetailsLevelEnum = typeof LDAPSyncLogDetailsLevelEnum[keyof typeof LDAPSyncLogDetailsLevelEnum];

export interface LDAPSyncLogEntry {
    'id': number;
    'timestamp': string;
    'level': LDAPSyncLogEntryLevelEnum;
    'message': string;
    'username'?: string;
    'details'?: string;
    'sync_session_id': string;
}

export const LDAPSyncLogEntryLevelEnum = {
    Info: 'info',
    Warning: 'warning',
    Error: 'error'
} as const;

export type LDAPSyncLogEntryLevelEnum = typeof LDAPSyncLogEntryLevelEnum[keyof typeof LDAPSyncLogEntryLevelEnum];

export interface LDAPSyncLogs {
    'logs'?: Array<LDAPSyncLogEntry>;
    'total'?: number;
    'has_more'?: boolean;
}
export interface LDAPSyncProgress {
    'is_running': boolean;
    'progress': number;
    'current_step': string;
    'processed_items': number;
    'total_items': number;
    'estimated_time': string;
    'start_time': string;
    'sync_id': string;
}
export interface LDAPSyncStartResponse {
    'message'?: string;
    'sync_id'?: string;
    'estimated_duration'?: string;
}
export interface LDAPSyncStatus {
    'status': string;
    'is_running': boolean;
    'last_sync_time'?: string;
    'total_users': number;
    'synced_users': number;
    'errors': number;
    'warnings': number;
    'last_sync_duration'?: string;
}
/**
 * Type of license feature
 */

export const LicenseFeature = {
    Sso: 'sso',
    Ldap: 'ldap',
    CorpNotifChannels: 'corp_notif_channels'
} as const;

export type LicenseFeature = typeof LicenseFeature[keyof typeof LicenseFeature];


export interface LicenseStatusResponse {
    'license': LicenseStatusResponseLicense;
}
export interface LicenseStatusResponseLicense {
    /**
     * License ID
     */
    'id'?: string;
    'type'?: LicenseType;
    /**
     * When the license was issued
     */
    'issued_at'?: string;
    /**
     * When the license expires
     */
    'expires_at'?: string;
    /**
     * Whether the license is currently valid
     */
    'is_valid'?: boolean;
    /**
     * Whether the license has expired
     */
    'is_expired'?: boolean;
    /**
     * Number of days until license expires (negative if expired)
     */
    'days_until_expiry'?: number;
    /**
     * The full license text
     */
    'license_text'?: string;
    /**
     * List of features available in this license
     */
    'features'?: Array<LicenseFeature>;
}


/**
 * Type of license
 */

export const LicenseType = {
    Trial: 'trial',
    TrialSelfSigned: 'trial-self-signed',
    Commercial: 'commercial',
    Individual: 'individual'
} as const;

export type LicenseType = typeof LicenseType[keyof typeof LicenseType];


export interface ListFeaturesResponse {
    'items': Array<Feature>;
    'pagination': Pagination;
}

export const LogicalOperator = {
    And: 'and',
    Or: 'or',
    AndNot: 'and_not'
} as const;

export type LogicalOperator = typeof LogicalOperator[keyof typeof LogicalOperator];


export interface LoginRequest {
    'username': string;
    'password': string;
}
export interface LoginResponse {
    'access_token': string;
    'refresh_token': string;
    'expires_in': number;
    'is_tmp_password': boolean;
}
export interface ModelError {
    'error': ErrorError;
}
export interface Pagination {
    'total': number;
    'page': number;
    'per_page': number;
}
export interface ProductInfoResponse {
    /**
     * Unique client identifier for this installation
     */
    'client_id': string;
    /**
     * When the client ID was created
     */
    'created_at': string;
}
export interface Project {
    'id': string;
    'name': string;
    'description': string;
    /**
     * API key for SDK access
     */
    'api_key': string;
    'created_at': string;
}
export interface ProjectResponse {
    'project': Project;
}
export interface RefreshTokenRequest {
    'refresh_token': string;
}
export interface RefreshTokenResponse {
    'access_token': string;
    'refresh_token': string;
    'expires_in': number;
}
export interface ResetPasswordRequest {
    'token': string;
    'new_password': string;
}
export interface Rule {
    'id': string;
    'feature_id': string;
    'conditions': RuleConditionExpression;
    'segment_id'?: string;
    'is_customized': boolean;
    'action': RuleAction;
    'flag_variant_id'?: string;
    'priority': number;
    'created_at': string;
}


/**
 * Type of rule action
 */

export const RuleAction = {
    Assign: 'assign',
    Include: 'include',
    Exclude: 'exclude'
} as const;

export type RuleAction = typeof RuleAction[keyof typeof RuleAction];


export interface RuleAttributeEntity {
    'name': string;
    'description'?: string;
}
/**
 * Single condition item
 */
export interface RuleCondition {
    /**
     * Attribute to match in the rule condition
     */
    'attribute': string;
    'operator': RuleOperator;
    'value': any;
}


/**
 * Boolean expression tree for conditions
 */
export interface RuleConditionExpression {
    'condition'?: RuleCondition;
    'group'?: RuleConditionGroup;
}
export interface RuleConditionGroup {
    'operator': LogicalOperator;
    'children': Array<RuleConditionExpression>;
}


/**
 * Operator for condition comparison
 */

export const RuleOperator = {
    Eq: 'eq',
    Neq: 'neq',
    In: 'in',
    NotIn: 'not_in',
    Gt: 'gt',
    Gte: 'gte',
    Lt: 'lt',
    Lte: 'lte',
    Regex: 'regex',
    Percentage: 'percentage'
} as const;

export type RuleOperator = typeof RuleOperator[keyof typeof RuleOperator];


export interface RuleResponse {
    'rule': Rule;
}
export interface SSOCallbackRequest {
    /**
     * Name of the SSO provider
     */
    'provider': string;
    /**
     * Response from SSO provider (code for OIDC, SAML response for SAML)
     */
    'response': string;
    /**
     * State parameter for CSRF protection
     */
    'state': string;
}
export interface SSOInitiateResponse {
    /**
     * URL to redirect user for SSO login
     */
    'redirect_url': string;
}
export interface SSOProvider {
    /**
     * Internal name of the provider
     */
    'name': string;
    /**
     * Display name for UI
     */
    'display_name': string;
    /**
     * Type of SSO provider
     */
    'type': SSOProviderTypeEnum;
    /**
     * URL to provider icon
     */
    'icon_url'?: string;
    /**
     * Whether the provider is enabled
     */
    'enabled': boolean;
}

export const SSOProviderTypeEnum = {
    Saml: 'saml'
} as const;

export type SSOProviderTypeEnum = typeof SSOProviderTypeEnum[keyof typeof SSOProviderTypeEnum];

export interface SSOProvidersResponse {
    'providers': Array<SSOProvider>;
}
export interface Segment {
    'id': string;
    'project_id': string;
    'name': string;
    'description'?: string;
    'conditions': RuleConditionExpression;
    'created_at': string;
    'updated_at': string;
}
export interface SegmentResponse {
    'segment': Segment;
}
export interface SetSuperuserStatusRequest {
    'is_superuser': boolean;
}
export interface SetUserActiveStatusRequest {
    'is_active': boolean;
}
/**
 * Sort order (ascending or descending)
 */

export const SortOrder = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type SortOrder = typeof SortOrder[keyof typeof SortOrder];


export interface SuccessResponse {
    'message'?: string;
}
export interface ToggleFeatureRequest {
    'enabled': boolean;
}
export interface TwoFAConfirmRequest {
    'code': string;
}
export interface TwoFADisableRequest {
    'email_code': string;
}
export interface TwoFAResetRequest {
    'email_code': string;
}
export interface TwoFASetupResponse {
    'secret': string;
    'qr_url': string;
    /**
     * Base64 PNG QR image
     */
    'qr_image': string;
}
export interface TwoFAVerifyRequest {
    'code': string;
    'session_id': string;
}
export interface TwoFAVerifyResponse {
    'access_token': string;
    'refresh_token': string;
    'expires_in': number;
}
export interface UpdateFeatureScheduleRequest {
    'starts_at'?: string;
    'ends_at'?: string;
    'cron_expr'?: string;
    'timezone': string;
    'action': FeatureScheduleAction;
}


export interface UpdateLicenseAcceptanceRequest {
    /**
     * Flag indicating whether the user accepts the license agreement
     */
    'accepted': boolean;
}
export interface UpdateLicenseRequest {
    /**
     * The license key text
     */
    'license_text': string;
}
export interface UpdateProjectRequest {
    'name': string;
    'description': string;
}
export interface UpdateSegmentRequest {
    'name': string;
    'description'?: string;
    'conditions': RuleConditionExpression;
}
export interface User {
    'id': number;
    'username': string;
    'email': string;
    'is_superuser': boolean;
    'is_active': boolean;
    'is_external': boolean;
    'is_tmp_password': boolean;
    'two_fa_enabled': boolean;
    /**
     * Flag indicating whether the user has accepted the license agreement
     */
    'license_accepted': boolean;
    'created_at': string;
    'last_login'?: string;
    /**
     * Map of project_id to list of permission keys for that project. Contains only projects where user has membership.
     */
    'project_permissions'?: { [key: string]: Array<string>; };
}

/**
 * DefaultApi - axios parameter creator
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add new project
         * @param {AddProjectRequest} addProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProject: async (addProjectRequest: AddProjectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addProjectRequest' is not null or undefined
            assertParamExists('addProject', 'addProjectRequest', addProjectRequest)
            const localVarPath = `/api/v1/projects/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addProjectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Archive a project
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveProject: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('archiveProject', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{project_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancel ongoing synchronization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelLDAPSync: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/ldap/sync/cancel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Approve enable 2FA (code from app)
         * @param {TwoFAConfirmRequest} twoFAConfirmRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirm2FA: async (twoFAConfirmRequest: TwoFAConfirmRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'twoFAConfirmRequest' is not null or undefined
            assertParamExists('confirm2FA', 'twoFAConfirmRequest', twoFAConfirmRequest)
            const localVarPath = `/api/v1/users/me/2fa/confirm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(twoFAConfirmRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finishes the SAML authentication flow.   The Identity Provider sends an HTTP-POST request that contains **SAMLResponse** (mandatory, Base64-encoded `<samlp:Response>` XML) and the optional **RelayState** parameter.   On success the service creates a user session (cookie or JWT) and redirects the browser to the application UI. 
         * @summary Assertion Consumer Service (ACS) endpoint
         * @param {string} sAMLResponse Base64-encoded IdP &#x60;&lt;samlp:Response&gt;&#x60; document
         * @param {string} relayState Value round-tripped from the initial authentication request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumeSAMLAssertion: async (sAMLResponse: string, relayState: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sAMLResponse' is not null or undefined
            assertParamExists('consumeSAMLAssertion', 'sAMLResponse', sAMLResponse)
            // verify required parameter 'relayState' is not null or undefined
            assertParamExists('consumeSAMLAssertion', 'relayState', relayState)
            const localVarPath = `/api/v1/saml/acs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (sAMLResponse !== undefined) { 
                localVarFormParams.set('SAMLResponse', sAMLResponse as any);
            }
    
            if (relayState !== undefined) { 
                localVarFormParams.set('RelayState', relayState as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create flag variant for feature
         * @param {string} featureId 
         * @param {CreateFlagVariantRequest} createFlagVariantRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeatureFlagVariant: async (featureId: string, createFlagVariantRequest: CreateFlagVariantRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'featureId' is not null or undefined
            assertParamExists('createFeatureFlagVariant', 'featureId', featureId)
            // verify required parameter 'createFlagVariantRequest' is not null or undefined
            assertParamExists('createFeatureFlagVariant', 'createFlagVariantRequest', createFlagVariantRequest)
            const localVarPath = `/api/v1/features/{feature_id}/variants`
                .replace(`{${"feature_id"}}`, encodeURIComponent(String(featureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFlagVariantRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create rule for feature
         * @param {string} featureId 
         * @param {CreateRuleRequest} createRuleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeatureRule: async (featureId: string, createRuleRequest: CreateRuleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'featureId' is not null or undefined
            assertParamExists('createFeatureRule', 'featureId', featureId)
            // verify required parameter 'createRuleRequest' is not null or undefined
            assertParamExists('createFeatureRule', 'createRuleRequest', createRuleRequest)
            const localVarPath = `/api/v1/features/{feature_id}/rules`
                .replace(`{${"feature_id"}}`, encodeURIComponent(String(featureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create schedule for feature
         * @param {string} featureId 
         * @param {CreateFeatureScheduleRequest} createFeatureScheduleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeatureSchedule: async (featureId: string, createFeatureScheduleRequest: CreateFeatureScheduleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'featureId' is not null or undefined
            assertParamExists('createFeatureSchedule', 'featureId', featureId)
            // verify required parameter 'createFeatureScheduleRequest' is not null or undefined
            assertParamExists('createFeatureSchedule', 'createFeatureScheduleRequest', createFeatureScheduleRequest)
            const localVarPath = `/api/v1/features/{feature_id}/schedules`
                .replace(`{${"feature_id"}}`, encodeURIComponent(String(featureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFeatureScheduleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create feature for project
         * @param {string} projectId 
         * @param {CreateFeatureRequest} createFeatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectFeature: async (projectId: string, createFeatureRequest: CreateFeatureRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createProjectFeature', 'projectId', projectId)
            // verify required parameter 'createFeatureRequest' is not null or undefined
            assertParamExists('createProjectFeature', 'createFeatureRequest', createFeatureRequest)
            const localVarPath = `/api/v1/projects/{project_id}/features`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFeatureRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create segment for project
         * @param {string} projectId 
         * @param {CreateSegmentRequest} createSegmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectSegment: async (projectId: string, createSegmentRequest: CreateSegmentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createProjectSegment', 'projectId', projectId)
            // verify required parameter 'createSegmentRequest' is not null or undefined
            assertParamExists('createProjectSegment', 'createSegmentRequest', createSegmentRequest)
            const localVarPath = `/api/v1/projects/{project_id}/segments`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSegmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create rule attribute
         * @param {CreateRuleAttributeRequest} createRuleAttributeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRuleAttribute: async (createRuleAttributeRequest: CreateRuleAttributeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRuleAttributeRequest' is not null or undefined
            assertParamExists('createRuleAttribute', 'createRuleAttributeRequest', createRuleAttributeRequest)
            const localVarPath = `/api/v1/rule_attributes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRuleAttributeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new user (superuser only)
         * @param {CreateUserRequest} createUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (createUserRequest: CreateUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserRequest' is not null or undefined
            assertParamExists('createUser', 'createUserRequest', createUserRequest)
            const localVarPath = `/api/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete feature
         * @param {string} featureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeature: async (featureId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'featureId' is not null or undefined
            assertParamExists('deleteFeature', 'featureId', featureId)
            const localVarPath = `/api/v1/features/{feature_id}`
                .replace(`{${"feature_id"}}`, encodeURIComponent(String(featureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete feature schedule by ID
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeatureSchedule: async (scheduleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('deleteFeatureSchedule', 'scheduleId', scheduleId)
            const localVarPath = `/api/v1/feature-schedules/{schedule_id}`
                .replace(`{${"schedule_id"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete LDAP configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLDAPConfig: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/ldap/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete rule attribute
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRuleAttribute: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteRuleAttribute', 'name', name)
            const localVarPath = `/api/v1/rule_attributes/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete segment
         * @param {string} segmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSegment: async (segmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'segmentId' is not null or undefined
            assertParamExists('deleteSegment', 'segmentId', segmentId)
            const localVarPath = `/api/v1/segments/{segment_id}`
                .replace(`{${"segment_id"}}`, encodeURIComponent(String(segmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a user (superuser only, cannot delete superusers)
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUser', 'userId', userId)
            const localVarPath = `/api/v1/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Disable 2FA (using email-confirmation)
         * @param {TwoFADisableRequest} twoFADisableRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disable2FA: async (twoFADisableRequest: TwoFADisableRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'twoFADisableRequest' is not null or undefined
            assertParamExists('disable2FA', 'twoFADisableRequest', twoFADisableRequest)
            const localVarPath = `/api/v1/users/me/2fa/disable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(twoFADisableRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request a password reset
         * @param {ForgotPasswordRequest} forgotPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPassword: async (forgotPasswordRequest: ForgotPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'forgotPasswordRequest' is not null or undefined
            assertParamExists('forgotPassword', 'forgotPasswordRequest', forgotPasswordRequest)
            const localVarPath = `/api/v1/auth/forgot-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forgotPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get current user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get feature with rules and variants
         * @param {string} featureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeature: async (featureId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'featureId' is not null or undefined
            assertParamExists('getFeature', 'featureId', featureId)
            const localVarPath = `/api/v1/features/{feature_id}`
                .replace(`{${"feature_id"}}`, encodeURIComponent(String(featureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get feature schedule by ID
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureSchedule: async (scheduleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('getFeatureSchedule', 'scheduleId', scheduleId)
            const localVarPath = `/api/v1/feature-schedules/{schedule_id}`
                .replace(`{${"schedule_id"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get LDAP configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLDAPConfig: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/ldap/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get LDAP statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLDAPStatistics: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/ldap/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get synchronization log details
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLDAPSyncLogDetails: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getLDAPSyncLogDetails', 'id', id)
            const localVarPath = `/api/v1/ldap/sync/logs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get synchronization logs
         * @param {number} [limit] 
         * @param {GetLDAPSyncLogsLevelEnum} [level] 
         * @param {string} [syncId] 
         * @param {string} [username] 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLDAPSyncLogs: async (limit?: number, level?: GetLDAPSyncLogsLevelEnum, syncId?: string, username?: string, from?: string, to?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/ldap/sync/logs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (syncId !== undefined) {
                localVarQueryParameter['sync_id'] = syncId;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get synchronization progress
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLDAPSyncProgress: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/ldap/sync/progress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get synchronization status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLDAPSyncStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/ldap/sync/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the current license status including validity, expiration date, and type
         * @summary Get license status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicenseStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/license/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get product information including client ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/product/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get project details
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProject', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{project_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get SAML metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSAMLMetadata: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/saml/metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get available SSO providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSSOProviders: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/sso/providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get segment by ID
         * @param {string} segmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegment: async (segmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'segmentId' is not null or undefined
            assertParamExists('getSegment', 'segmentId', segmentId)
            const localVarPath = `/api/v1/segments/{segment_id}`
                .replace(`{${"segment_id"}}`, encodeURIComponent(String(segmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all feature schedules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllFeatureSchedules: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/feature-schedules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List flag variants for feature
         * @param {string} featureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFeatureFlagVariants: async (featureId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'featureId' is not null or undefined
            assertParamExists('listFeatureFlagVariants', 'featureId', featureId)
            const localVarPath = `/api/v1/features/{feature_id}/variants`
                .replace(`{${"feature_id"}}`, encodeURIComponent(String(featureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List rules for feature
         * @param {string} featureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFeatureRules: async (featureId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'featureId' is not null or undefined
            assertParamExists('listFeatureRules', 'featureId', featureId)
            const localVarPath = `/api/v1/features/{feature_id}/rules`
                .replace(`{${"feature_id"}}`, encodeURIComponent(String(featureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List schedules for feature
         * @param {string} featureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFeatureSchedules: async (featureId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'featureId' is not null or undefined
            assertParamExists('listFeatureSchedules', 'featureId', featureId)
            const localVarPath = `/api/v1/features/{feature_id}/schedules`
                .replace(`{${"feature_id"}}`, encodeURIComponent(String(featureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List features for project
         * @param {string} projectId 
         * @param {ListProjectFeaturesKindEnum} [kind] Filter by feature kind
         * @param {boolean} [enabled] Filter by enabled state
         * @param {string} [textSelector] Case-insensitive text search across key, name, description, rollout_key
         * @param {ListProjectFeaturesSortByEnum} [sortBy] Sort by field
         * @param {SortOrder} [sortOrder] Sort order
         * @param {number} [page] Page number (starts from 1)
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectFeatures: async (projectId: string, kind?: ListProjectFeaturesKindEnum, enabled?: boolean, textSelector?: string, sortBy?: ListProjectFeaturesSortByEnum, sortOrder?: SortOrder, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('listProjectFeatures', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{project_id}/features`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (kind !== undefined) {
                localVarQueryParameter['kind'] = kind;
            }

            if (enabled !== undefined) {
                localVarQueryParameter['enabled'] = enabled;
            }

            if (textSelector !== undefined) {
                localVarQueryParameter['text_selector'] = textSelector;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List segments for project
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectSegments: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('listProjectSegments', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{project_id}/segments`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get projects list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List of rule attributes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuleAttributes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/rule_attributes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get desync feature IDs by segment ID
         * @param {string} segmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSegmentDesyncFeatureIDs: async (segmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'segmentId' is not null or undefined
            assertParamExists('listSegmentDesyncFeatureIDs', 'segmentId', segmentId)
            const localVarPath = `/api/v1/segments/{segment_id}/desync-features`
                .replace(`{${"segment_id"}}`, encodeURIComponent(String(segmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all users (superuser only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Authenticate user and get access token
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginRequest: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('login', 'loginRequest', loginRequest)
            const localVarPath = `/api/v1/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refresh access token
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (refreshTokenRequest: RefreshTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshTokenRequest' is not null or undefined
            assertParamExists('refreshToken', 'refreshTokenRequest', refreshTokenRequest)
            const localVarPath = `/api/v1/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset/generate secret 2FA (using email-confirmation)
         * @param {TwoFAResetRequest} twoFAResetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reset2FA: async (twoFAResetRequest: TwoFAResetRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'twoFAResetRequest' is not null or undefined
            assertParamExists('reset2FA', 'twoFAResetRequest', twoFAResetRequest)
            const localVarPath = `/api/v1/users/me/2fa/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(twoFAResetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset password using token
         * @param {ResetPasswordRequest} resetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword: async (resetPasswordRequest: ResetPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetPasswordRequest' is not null or undefined
            assertParamExists('resetPassword', 'resetPasswordRequest', resetPasswordRequest)
            const localVarPath = `/api/v1/auth/reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Handle SSO callback from Keycloak
         * @param {SSOCallbackRequest} sSOCallbackRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sSOCallback: async (sSOCallbackRequest: SSOCallbackRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sSOCallbackRequest' is not null or undefined
            assertParamExists('sSOCallback', 'sSOCallbackRequest', sSOCallbackRequest)
            const localVarPath = `/api/v1/auth/sso/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sSOCallbackRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Initiate SSO login flow
         * @param {string} provider Name of the SSO provider to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sSOInitiate: async (provider: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('sSOInitiate', 'provider', provider)
            const localVarPath = `/api/v1/auth/sso/initiate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set or unset superuser status (superuser only, cannot modify admin user)
         * @param {number} userId 
         * @param {SetSuperuserStatusRequest} setSuperuserStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSuperuserStatus: async (userId: number, setSuperuserStatusRequest: SetSuperuserStatusRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('setSuperuserStatus', 'userId', userId)
            // verify required parameter 'setSuperuserStatusRequest' is not null or undefined
            assertParamExists('setSuperuserStatus', 'setSuperuserStatusRequest', setSuperuserStatusRequest)
            const localVarPath = `/api/v1/users/{user_id}/superuser`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setSuperuserStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set or unset user active status (superuser only)
         * @param {number} userId 
         * @param {SetUserActiveStatusRequest} setUserActiveStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserActiveStatus: async (userId: number, setUserActiveStatusRequest: SetUserActiveStatusRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('setUserActiveStatus', 'userId', userId)
            // verify required parameter 'setUserActiveStatusRequest' is not null or undefined
            assertParamExists('setUserActiveStatus', 'setUserActiveStatusRequest', setUserActiveStatusRequest)
            const localVarPath = `/api/v1/users/{user_id}/active`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setUserActiveStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Begin setup 2FA (generate secret and QR-code)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setup2FA: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/me/2fa/setup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Synchronize customized feature rule
         * @param {string} featureId 
         * @param {string} ruleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncCustomizedFeatureRule: async (featureId: string, ruleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'featureId' is not null or undefined
            assertParamExists('syncCustomizedFeatureRule', 'featureId', featureId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('syncCustomizedFeatureRule', 'ruleId', ruleId)
            const localVarPath = `/api/v1/features/{feature_id}/rules/{rule_id}/sync`
                .replace(`{${"feature_id"}}`, encodeURIComponent(String(featureId)))
                .replace(`{${"rule_id"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start user synchronization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncLDAPUsers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/ldap/sync/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Test LDAP connection
         * @param {LDAPConnectionTest} lDAPConnectionTest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testLDAPConnection: async (lDAPConnectionTest: LDAPConnectionTest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lDAPConnectionTest' is not null or undefined
            assertParamExists('testLDAPConnection', 'lDAPConnectionTest', lDAPConnectionTest)
            const localVarPath = `/api/v1/ldap/test-connection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lDAPConnectionTest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Toggle feature enabled state
         * @param {string} featureId 
         * @param {ToggleFeatureRequest} toggleFeatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleFeature: async (featureId: string, toggleFeatureRequest: ToggleFeatureRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'featureId' is not null or undefined
            assertParamExists('toggleFeature', 'featureId', featureId)
            // verify required parameter 'toggleFeatureRequest' is not null or undefined
            assertParamExists('toggleFeature', 'toggleFeatureRequest', toggleFeatureRequest)
            const localVarPath = `/api/v1/features/{feature_id}/toggle`
                .replace(`{${"feature_id"}}`, encodeURIComponent(String(featureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(toggleFeatureRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update feature with rules and variants
         * @param {string} featureId 
         * @param {CreateFeatureRequest} createFeatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeature: async (featureId: string, createFeatureRequest: CreateFeatureRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'featureId' is not null or undefined
            assertParamExists('updateFeature', 'featureId', featureId)
            // verify required parameter 'createFeatureRequest' is not null or undefined
            assertParamExists('updateFeature', 'createFeatureRequest', createFeatureRequest)
            const localVarPath = `/api/v1/features/{feature_id}`
                .replace(`{${"feature_id"}}`, encodeURIComponent(String(featureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFeatureRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update feature schedule by ID
         * @param {string} scheduleId 
         * @param {UpdateFeatureScheduleRequest} updateFeatureScheduleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeatureSchedule: async (scheduleId: string, updateFeatureScheduleRequest: UpdateFeatureScheduleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('updateFeatureSchedule', 'scheduleId', scheduleId)
            // verify required parameter 'updateFeatureScheduleRequest' is not null or undefined
            assertParamExists('updateFeatureSchedule', 'updateFeatureScheduleRequest', updateFeatureScheduleRequest)
            const localVarPath = `/api/v1/feature-schedules/{schedule_id}`
                .replace(`{${"schedule_id"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFeatureScheduleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create or update LDAP configuration
         * @param {LDAPConfig} lDAPConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLDAPConfig: async (lDAPConfig: LDAPConfig, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lDAPConfig' is not null or undefined
            assertParamExists('updateLDAPConfig', 'lDAPConfig', lDAPConfig)
            const localVarPath = `/api/v1/ldap/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lDAPConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the system license with a new license key
         * @summary Update license
         * @param {UpdateLicenseRequest} updateLicenseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLicense: async (updateLicenseRequest: UpdateLicenseRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateLicenseRequest' is not null or undefined
            assertParamExists('updateLicense', 'updateLicenseRequest', updateLicenseRequest)
            const localVarPath = `/api/v1/license`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateLicenseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update license acceptance status
         * @param {UpdateLicenseAcceptanceRequest} updateLicenseAcceptanceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLicenseAcceptance: async (updateLicenseAcceptanceRequest: UpdateLicenseAcceptanceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateLicenseAcceptanceRequest' is not null or undefined
            assertParamExists('updateLicenseAcceptance', 'updateLicenseAcceptanceRequest', updateLicenseAcceptanceRequest)
            const localVarPath = `/api/v1/users/me/license-acceptance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateLicenseAcceptanceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update project name and description
         * @param {string} projectId 
         * @param {UpdateProjectRequest} updateProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject: async (projectId: string, updateProjectRequest: UpdateProjectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateProject', 'projectId', projectId)
            // verify required parameter 'updateProjectRequest' is not null or undefined
            assertParamExists('updateProject', 'updateProjectRequest', updateProjectRequest)
            const localVarPath = `/api/v1/projects/{project_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProjectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update segment
         * @param {string} segmentId 
         * @param {UpdateSegmentRequest} updateSegmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSegment: async (segmentId: string, updateSegmentRequest: UpdateSegmentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'segmentId' is not null or undefined
            assertParamExists('updateSegment', 'segmentId', segmentId)
            // verify required parameter 'updateSegmentRequest' is not null or undefined
            assertParamExists('updateSegment', 'updateSegmentRequest', updateSegmentRequest)
            const localVarPath = `/api/v1/segments/{segment_id}`
                .replace(`{${"segment_id"}}`, encodeURIComponent(String(segmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSegmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change my password
         * @param {ChangeUserPasswordRequest} changeUserPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userChangeMyPassword: async (changeUserPasswordRequest: ChangeUserPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changeUserPasswordRequest' is not null or undefined
            assertParamExists('userChangeMyPassword', 'changeUserPasswordRequest', changeUserPasswordRequest)
            const localVarPath = `/api/v1/users/me/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changeUserPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verify 2FA-code on login
         * @param {TwoFAVerifyRequest} twoFAVerifyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verify2FA: async (twoFAVerifyRequest: TwoFAVerifyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'twoFAVerifyRequest' is not null or undefined
            assertParamExists('verify2FA', 'twoFAVerifyRequest', twoFAVerifyRequest)
            const localVarPath = `/api/v1/auth/2fa/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(twoFAVerifyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add new project
         * @param {AddProjectRequest} addProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addProject(addProjectRequest: AddProjectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addProject(addProjectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.addProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Archive a project
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archiveProject(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.archiveProject(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.archiveProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Cancel ongoing synchronization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelLDAPSync(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelLDAPSync(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.cancelLDAPSync']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Approve enable 2FA (code from app)
         * @param {TwoFAConfirmRequest} twoFAConfirmRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirm2FA(twoFAConfirmRequest: TwoFAConfirmRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirm2FA(twoFAConfirmRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.confirm2FA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Finishes the SAML authentication flow.   The Identity Provider sends an HTTP-POST request that contains **SAMLResponse** (mandatory, Base64-encoded `<samlp:Response>` XML) and the optional **RelayState** parameter.   On success the service creates a user session (cookie or JWT) and redirects the browser to the application UI. 
         * @summary Assertion Consumer Service (ACS) endpoint
         * @param {string} sAMLResponse Base64-encoded IdP &#x60;&lt;samlp:Response&gt;&#x60; document
         * @param {string} relayState Value round-tripped from the initial authentication request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async consumeSAMLAssertion(sAMLResponse: string, relayState: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Error>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.consumeSAMLAssertion(sAMLResponse, relayState, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.consumeSAMLAssertion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create flag variant for feature
         * @param {string} featureId 
         * @param {CreateFlagVariantRequest} createFlagVariantRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFeatureFlagVariant(featureId: string, createFlagVariantRequest: CreateFlagVariantRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlagVariantResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFeatureFlagVariant(featureId, createFlagVariantRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createFeatureFlagVariant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create rule for feature
         * @param {string} featureId 
         * @param {CreateRuleRequest} createRuleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFeatureRule(featureId: string, createRuleRequest: CreateRuleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFeatureRule(featureId, createRuleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createFeatureRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create schedule for feature
         * @param {string} featureId 
         * @param {CreateFeatureScheduleRequest} createFeatureScheduleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFeatureSchedule(featureId: string, createFeatureScheduleRequest: CreateFeatureScheduleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureScheduleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFeatureSchedule(featureId, createFeatureScheduleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createFeatureSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create feature for project
         * @param {string} projectId 
         * @param {CreateFeatureRequest} createFeatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProjectFeature(projectId: string, createFeatureRequest: CreateFeatureRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProjectFeature(projectId, createFeatureRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createProjectFeature']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create segment for project
         * @param {string} projectId 
         * @param {CreateSegmentRequest} createSegmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProjectSegment(projectId: string, createSegmentRequest: CreateSegmentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SegmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProjectSegment(projectId, createSegmentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createProjectSegment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create rule attribute
         * @param {CreateRuleAttributeRequest} createRuleAttributeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRuleAttribute(createRuleAttributeRequest: CreateRuleAttributeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRuleAttribute(createRuleAttributeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createRuleAttribute']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new user (superuser only)
         * @param {CreateUserRequest} createUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(createUserRequest: CreateUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(createUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete feature
         * @param {string} featureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFeature(featureId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFeature(featureId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteFeature']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete feature schedule by ID
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFeatureSchedule(scheduleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFeatureSchedule(scheduleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteFeatureSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete LDAP configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLDAPConfig(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLDAPConfig(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteLDAPConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete rule attribute
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRuleAttribute(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRuleAttribute(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteRuleAttribute']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete segment
         * @param {string} segmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSegment(segmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSegment(segmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteSegment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a user (superuser only, cannot delete superusers)
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Disable 2FA (using email-confirmation)
         * @param {TwoFADisableRequest} twoFADisableRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disable2FA(twoFADisableRequest: TwoFADisableRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disable2FA(twoFADisableRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.disable2FA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Request a password reset
         * @param {ForgotPasswordRequest} forgotPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forgotPassword(forgotPasswordRequest: ForgotPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forgotPassword(forgotPasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.forgotPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get current user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getCurrentUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get feature with rules and variants
         * @param {string} featureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeature(featureId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureDetailsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeature(featureId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getFeature']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get feature schedule by ID
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeatureSchedule(scheduleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureScheduleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeatureSchedule(scheduleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getFeatureSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get LDAP configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLDAPConfig(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LDAPConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLDAPConfig(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getLDAPConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get LDAP statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLDAPStatistics(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LDAPStatistics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLDAPStatistics(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getLDAPStatistics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get synchronization log details
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLDAPSyncLogDetails(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LDAPSyncLogDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLDAPSyncLogDetails(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getLDAPSyncLogDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get synchronization logs
         * @param {number} [limit] 
         * @param {GetLDAPSyncLogsLevelEnum} [level] 
         * @param {string} [syncId] 
         * @param {string} [username] 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLDAPSyncLogs(limit?: number, level?: GetLDAPSyncLogsLevelEnum, syncId?: string, username?: string, from?: string, to?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LDAPSyncLogs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLDAPSyncLogs(limit, level, syncId, username, from, to, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getLDAPSyncLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get synchronization progress
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLDAPSyncProgress(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LDAPSyncProgress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLDAPSyncProgress(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getLDAPSyncProgress']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get synchronization status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLDAPSyncStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LDAPSyncStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLDAPSyncStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getLDAPSyncStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the current license status including validity, expiration date, and type
         * @summary Get license status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLicenseStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LicenseStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLicenseStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getLicenseStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get product information including client ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getProductInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get project details
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProject(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProject(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get SAML metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSAMLMetadata(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSAMLMetadata(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getSAMLMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get available SSO providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSSOProviders(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SSOProvidersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSSOProviders(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getSSOProviders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get segment by ID
         * @param {string} segmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSegment(segmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SegmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSegment(segmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getSegment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all feature schedules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllFeatureSchedules(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FeatureSchedule>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllFeatureSchedules(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listAllFeatureSchedules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List flag variants for feature
         * @param {string} featureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFeatureFlagVariants(featureId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FlagVariant>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFeatureFlagVariants(featureId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listFeatureFlagVariants']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List rules for feature
         * @param {string} featureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFeatureRules(featureId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Rule>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFeatureRules(featureId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listFeatureRules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List schedules for feature
         * @param {string} featureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFeatureSchedules(featureId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FeatureSchedule>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFeatureSchedules(featureId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listFeatureSchedules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List features for project
         * @param {string} projectId 
         * @param {ListProjectFeaturesKindEnum} [kind] Filter by feature kind
         * @param {boolean} [enabled] Filter by enabled state
         * @param {string} [textSelector] Case-insensitive text search across key, name, description, rollout_key
         * @param {ListProjectFeaturesSortByEnum} [sortBy] Sort by field
         * @param {SortOrder} [sortOrder] Sort order
         * @param {number} [page] Page number (starts from 1)
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjectFeatures(projectId: string, kind?: ListProjectFeaturesKindEnum, enabled?: boolean, textSelector?: string, sortBy?: ListProjectFeaturesSortByEnum, sortOrder?: SortOrder, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListFeaturesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjectFeatures(projectId, kind, enabled, textSelector, sortBy, sortOrder, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listProjectFeatures']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List segments for project
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjectSegments(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Segment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjectSegments(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listProjectSegments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get projects list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjects(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Project>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjects(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listProjects']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List of rule attributes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRuleAttributes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RuleAttributeEntity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRuleAttributes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listRuleAttributes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get desync feature IDs by segment ID
         * @param {string} segmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSegmentDesyncFeatureIDs(segmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSegmentDesyncFeatureIDs(segmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listSegmentDesyncFeatureIDs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all users (superuser only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Authenticate user and get access token
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Refresh access token
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(refreshTokenRequest: RefreshTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(refreshTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.refreshToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Reset/generate secret 2FA (using email-confirmation)
         * @param {TwoFAResetRequest} twoFAResetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reset2FA(twoFAResetRequest: TwoFAResetRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TwoFASetupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reset2FA(twoFAResetRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.reset2FA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Reset password using token
         * @param {ResetPasswordRequest} resetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPassword(resetPasswordRequest: ResetPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetPassword(resetPasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.resetPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Handle SSO callback from Keycloak
         * @param {SSOCallbackRequest} sSOCallbackRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sSOCallback(sSOCallbackRequest: SSOCallbackRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sSOCallback(sSOCallbackRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.sSOCallback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Initiate SSO login flow
         * @param {string} provider Name of the SSO provider to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sSOInitiate(provider: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SSOInitiateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sSOInitiate(provider, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.sSOInitiate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set or unset superuser status (superuser only, cannot modify admin user)
         * @param {number} userId 
         * @param {SetSuperuserStatusRequest} setSuperuserStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSuperuserStatus(userId: number, setSuperuserStatusRequest: SetSuperuserStatusRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSuperuserStatus(userId, setSuperuserStatusRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.setSuperuserStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set or unset user active status (superuser only)
         * @param {number} userId 
         * @param {SetUserActiveStatusRequest} setUserActiveStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setUserActiveStatus(userId: number, setUserActiveStatusRequest: SetUserActiveStatusRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setUserActiveStatus(userId, setUserActiveStatusRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.setUserActiveStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Begin setup 2FA (generate secret and QR-code)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setup2FA(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TwoFASetupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setup2FA(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.setup2FA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Synchronize customized feature rule
         * @param {string} featureId 
         * @param {string} ruleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncCustomizedFeatureRule(featureId: string, ruleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncCustomizedFeatureRule(featureId, ruleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.syncCustomizedFeatureRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Start user synchronization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncLDAPUsers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LDAPSyncStartResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncLDAPUsers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.syncLDAPUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Test LDAP connection
         * @param {LDAPConnectionTest} lDAPConnectionTest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testLDAPConnection(lDAPConnectionTest: LDAPConnectionTest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LDAPConnectionTestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testLDAPConnection(lDAPConnectionTest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.testLDAPConnection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Toggle feature enabled state
         * @param {string} featureId 
         * @param {ToggleFeatureRequest} toggleFeatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toggleFeature(featureId: string, toggleFeatureRequest: ToggleFeatureRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toggleFeature(featureId, toggleFeatureRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.toggleFeature']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update feature with rules and variants
         * @param {string} featureId 
         * @param {CreateFeatureRequest} createFeatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFeature(featureId: string, createFeatureRequest: CreateFeatureRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureDetailsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFeature(featureId, createFeatureRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateFeature']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update feature schedule by ID
         * @param {string} scheduleId 
         * @param {UpdateFeatureScheduleRequest} updateFeatureScheduleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFeatureSchedule(scheduleId: string, updateFeatureScheduleRequest: UpdateFeatureScheduleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureScheduleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFeatureSchedule(scheduleId, updateFeatureScheduleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateFeatureSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create or update LDAP configuration
         * @param {LDAPConfig} lDAPConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLDAPConfig(lDAPConfig: LDAPConfig, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LDAPConfigResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLDAPConfig(lDAPConfig, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateLDAPConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the system license with a new license key
         * @summary Update license
         * @param {UpdateLicenseRequest} updateLicenseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLicense(updateLicenseRequest: UpdateLicenseRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LicenseStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLicense(updateLicenseRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateLicense']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update license acceptance status
         * @param {UpdateLicenseAcceptanceRequest} updateLicenseAcceptanceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLicenseAcceptance(updateLicenseAcceptanceRequest: UpdateLicenseAcceptanceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLicenseAcceptance(updateLicenseAcceptanceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateLicenseAcceptance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update project name and description
         * @param {string} projectId 
         * @param {UpdateProjectRequest} updateProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProject(projectId: string, updateProjectRequest: UpdateProjectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProject(projectId, updateProjectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update segment
         * @param {string} segmentId 
         * @param {UpdateSegmentRequest} updateSegmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSegment(segmentId: string, updateSegmentRequest: UpdateSegmentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SegmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSegment(segmentId, updateSegmentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateSegment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Change my password
         * @param {ChangeUserPasswordRequest} changeUserPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userChangeMyPassword(changeUserPasswordRequest: ChangeUserPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userChangeMyPassword(changeUserPasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.userChangeMyPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Verify 2FA-code on login
         * @param {TwoFAVerifyRequest} twoFAVerifyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verify2FA(twoFAVerifyRequest: TwoFAVerifyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TwoFAVerifyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verify2FA(twoFAVerifyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.verify2FA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Add new project
         * @param {AddProjectRequest} addProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProject(addProjectRequest: AddProjectRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addProject(addProjectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Archive a project
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveProject(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.archiveProject(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancel ongoing synchronization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelLDAPSync(options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.cancelLDAPSync(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Approve enable 2FA (code from app)
         * @param {TwoFAConfirmRequest} twoFAConfirmRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirm2FA(twoFAConfirmRequest: TwoFAConfirmRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.confirm2FA(twoFAConfirmRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Finishes the SAML authentication flow.   The Identity Provider sends an HTTP-POST request that contains **SAMLResponse** (mandatory, Base64-encoded `<samlp:Response>` XML) and the optional **RelayState** parameter.   On success the service creates a user session (cookie or JWT) and redirects the browser to the application UI. 
         * @summary Assertion Consumer Service (ACS) endpoint
         * @param {string} sAMLResponse Base64-encoded IdP &#x60;&lt;samlp:Response&gt;&#x60; document
         * @param {string} relayState Value round-tripped from the initial authentication request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumeSAMLAssertion(sAMLResponse: string, relayState: string, options?: RawAxiosRequestConfig): AxiosPromise<Error> {
            return localVarFp.consumeSAMLAssertion(sAMLResponse, relayState, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create flag variant for feature
         * @param {string} featureId 
         * @param {CreateFlagVariantRequest} createFlagVariantRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeatureFlagVariant(featureId: string, createFlagVariantRequest: CreateFlagVariantRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlagVariantResponse> {
            return localVarFp.createFeatureFlagVariant(featureId, createFlagVariantRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create rule for feature
         * @param {string} featureId 
         * @param {CreateRuleRequest} createRuleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeatureRule(featureId: string, createRuleRequest: CreateRuleRequest, options?: RawAxiosRequestConfig): AxiosPromise<RuleResponse> {
            return localVarFp.createFeatureRule(featureId, createRuleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create schedule for feature
         * @param {string} featureId 
         * @param {CreateFeatureScheduleRequest} createFeatureScheduleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeatureSchedule(featureId: string, createFeatureScheduleRequest: CreateFeatureScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<FeatureScheduleResponse> {
            return localVarFp.createFeatureSchedule(featureId, createFeatureScheduleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create feature for project
         * @param {string} projectId 
         * @param {CreateFeatureRequest} createFeatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectFeature(projectId: string, createFeatureRequest: CreateFeatureRequest, options?: RawAxiosRequestConfig): AxiosPromise<FeatureResponse> {
            return localVarFp.createProjectFeature(projectId, createFeatureRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create segment for project
         * @param {string} projectId 
         * @param {CreateSegmentRequest} createSegmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectSegment(projectId: string, createSegmentRequest: CreateSegmentRequest, options?: RawAxiosRequestConfig): AxiosPromise<SegmentResponse> {
            return localVarFp.createProjectSegment(projectId, createSegmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create rule attribute
         * @param {CreateRuleAttributeRequest} createRuleAttributeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRuleAttribute(createRuleAttributeRequest: CreateRuleAttributeRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createRuleAttribute(createRuleAttributeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new user (superuser only)
         * @param {CreateUserRequest} createUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(createUserRequest: CreateUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateUserResponse> {
            return localVarFp.createUser(createUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete feature
         * @param {string} featureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeature(featureId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteFeature(featureId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete feature schedule by ID
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeatureSchedule(scheduleId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteFeatureSchedule(scheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete LDAP configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLDAPConfig(options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.deleteLDAPConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete rule attribute
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRuleAttribute(name: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRuleAttribute(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete segment
         * @param {string} segmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSegment(segmentId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSegment(segmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a user (superuser only, cannot delete superusers)
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Disable 2FA (using email-confirmation)
         * @param {TwoFADisableRequest} twoFADisableRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disable2FA(twoFADisableRequest: TwoFADisableRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.disable2FA(twoFADisableRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request a password reset
         * @param {ForgotPasswordRequest} forgotPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPassword(forgotPasswordRequest: ForgotPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.forgotPassword(forgotPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get current user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getCurrentUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get feature with rules and variants
         * @param {string} featureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeature(featureId: string, options?: RawAxiosRequestConfig): AxiosPromise<FeatureDetailsResponse> {
            return localVarFp.getFeature(featureId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get feature schedule by ID
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureSchedule(scheduleId: string, options?: RawAxiosRequestConfig): AxiosPromise<FeatureScheduleResponse> {
            return localVarFp.getFeatureSchedule(scheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get LDAP configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLDAPConfig(options?: RawAxiosRequestConfig): AxiosPromise<LDAPConfig> {
            return localVarFp.getLDAPConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get LDAP statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLDAPStatistics(options?: RawAxiosRequestConfig): AxiosPromise<LDAPStatistics> {
            return localVarFp.getLDAPStatistics(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get synchronization log details
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLDAPSyncLogDetails(id: number, options?: RawAxiosRequestConfig): AxiosPromise<LDAPSyncLogDetails> {
            return localVarFp.getLDAPSyncLogDetails(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get synchronization logs
         * @param {number} [limit] 
         * @param {GetLDAPSyncLogsLevelEnum} [level] 
         * @param {string} [syncId] 
         * @param {string} [username] 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLDAPSyncLogs(limit?: number, level?: GetLDAPSyncLogsLevelEnum, syncId?: string, username?: string, from?: string, to?: string, options?: RawAxiosRequestConfig): AxiosPromise<LDAPSyncLogs> {
            return localVarFp.getLDAPSyncLogs(limit, level, syncId, username, from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get synchronization progress
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLDAPSyncProgress(options?: RawAxiosRequestConfig): AxiosPromise<LDAPSyncProgress> {
            return localVarFp.getLDAPSyncProgress(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get synchronization status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLDAPSyncStatus(options?: RawAxiosRequestConfig): AxiosPromise<LDAPSyncStatus> {
            return localVarFp.getLDAPSyncStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the current license status including validity, expiration date, and type
         * @summary Get license status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicenseStatus(options?: RawAxiosRequestConfig): AxiosPromise<LicenseStatusResponse> {
            return localVarFp.getLicenseStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get product information including client ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductInfo(options?: RawAxiosRequestConfig): AxiosPromise<ProductInfoResponse> {
            return localVarFp.getProductInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get project details
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<ProjectResponse> {
            return localVarFp.getProject(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get SAML metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSAMLMetadata(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getSAMLMetadata(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get available SSO providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSSOProviders(options?: RawAxiosRequestConfig): AxiosPromise<SSOProvidersResponse> {
            return localVarFp.getSSOProviders(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get segment by ID
         * @param {string} segmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegment(segmentId: string, options?: RawAxiosRequestConfig): AxiosPromise<SegmentResponse> {
            return localVarFp.getSegment(segmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all feature schedules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllFeatureSchedules(options?: RawAxiosRequestConfig): AxiosPromise<Array<FeatureSchedule>> {
            return localVarFp.listAllFeatureSchedules(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List flag variants for feature
         * @param {string} featureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFeatureFlagVariants(featureId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlagVariant>> {
            return localVarFp.listFeatureFlagVariants(featureId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List rules for feature
         * @param {string} featureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFeatureRules(featureId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Rule>> {
            return localVarFp.listFeatureRules(featureId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List schedules for feature
         * @param {string} featureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFeatureSchedules(featureId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<FeatureSchedule>> {
            return localVarFp.listFeatureSchedules(featureId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List features for project
         * @param {string} projectId 
         * @param {ListProjectFeaturesKindEnum} [kind] Filter by feature kind
         * @param {boolean} [enabled] Filter by enabled state
         * @param {string} [textSelector] Case-insensitive text search across key, name, description, rollout_key
         * @param {ListProjectFeaturesSortByEnum} [sortBy] Sort by field
         * @param {SortOrder} [sortOrder] Sort order
         * @param {number} [page] Page number (starts from 1)
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectFeatures(projectId: string, kind?: ListProjectFeaturesKindEnum, enabled?: boolean, textSelector?: string, sortBy?: ListProjectFeaturesSortByEnum, sortOrder?: SortOrder, page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListFeaturesResponse> {
            return localVarFp.listProjectFeatures(projectId, kind, enabled, textSelector, sortBy, sortOrder, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List segments for project
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectSegments(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Segment>> {
            return localVarFp.listProjectSegments(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get projects list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects(options?: RawAxiosRequestConfig): AxiosPromise<Array<Project>> {
            return localVarFp.listProjects(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List of rule attributes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuleAttributes(options?: RawAxiosRequestConfig): AxiosPromise<Array<RuleAttributeEntity>> {
            return localVarFp.listRuleAttributes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get desync feature IDs by segment ID
         * @param {string} segmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSegmentDesyncFeatureIDs(segmentId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.listSegmentDesyncFeatureIDs(segmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all users (superuser only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(options?: RawAxiosRequestConfig): AxiosPromise<Array<User>> {
            return localVarFp.listUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Authenticate user and get access token
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponse> {
            return localVarFp.login(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refresh access token
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(refreshTokenRequest: RefreshTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<RefreshTokenResponse> {
            return localVarFp.refreshToken(refreshTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset/generate secret 2FA (using email-confirmation)
         * @param {TwoFAResetRequest} twoFAResetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reset2FA(twoFAResetRequest: TwoFAResetRequest, options?: RawAxiosRequestConfig): AxiosPromise<TwoFASetupResponse> {
            return localVarFp.reset2FA(twoFAResetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset password using token
         * @param {ResetPasswordRequest} resetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword(resetPasswordRequest: ResetPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.resetPassword(resetPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Handle SSO callback from Keycloak
         * @param {SSOCallbackRequest} sSOCallbackRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sSOCallback(sSOCallbackRequest: SSOCallbackRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponse> {
            return localVarFp.sSOCallback(sSOCallbackRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Initiate SSO login flow
         * @param {string} provider Name of the SSO provider to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sSOInitiate(provider: string, options?: RawAxiosRequestConfig): AxiosPromise<SSOInitiateResponse> {
            return localVarFp.sSOInitiate(provider, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set or unset superuser status (superuser only, cannot modify admin user)
         * @param {number} userId 
         * @param {SetSuperuserStatusRequest} setSuperuserStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSuperuserStatus(userId: number, setSuperuserStatusRequest: SetSuperuserStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.setSuperuserStatus(userId, setSuperuserStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set or unset user active status (superuser only)
         * @param {number} userId 
         * @param {SetUserActiveStatusRequest} setUserActiveStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserActiveStatus(userId: number, setUserActiveStatusRequest: SetUserActiveStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.setUserActiveStatus(userId, setUserActiveStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Begin setup 2FA (generate secret and QR-code)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setup2FA(options?: RawAxiosRequestConfig): AxiosPromise<TwoFASetupResponse> {
            return localVarFp.setup2FA(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Synchronize customized feature rule
         * @param {string} featureId 
         * @param {string} ruleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncCustomizedFeatureRule(featureId: string, ruleId: string, options?: RawAxiosRequestConfig): AxiosPromise<RuleResponse> {
            return localVarFp.syncCustomizedFeatureRule(featureId, ruleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start user synchronization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncLDAPUsers(options?: RawAxiosRequestConfig): AxiosPromise<LDAPSyncStartResponse> {
            return localVarFp.syncLDAPUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Test LDAP connection
         * @param {LDAPConnectionTest} lDAPConnectionTest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testLDAPConnection(lDAPConnectionTest: LDAPConnectionTest, options?: RawAxiosRequestConfig): AxiosPromise<LDAPConnectionTestResponse> {
            return localVarFp.testLDAPConnection(lDAPConnectionTest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Toggle feature enabled state
         * @param {string} featureId 
         * @param {ToggleFeatureRequest} toggleFeatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleFeature(featureId: string, toggleFeatureRequest: ToggleFeatureRequest, options?: RawAxiosRequestConfig): AxiosPromise<FeatureResponse> {
            return localVarFp.toggleFeature(featureId, toggleFeatureRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update feature with rules and variants
         * @param {string} featureId 
         * @param {CreateFeatureRequest} createFeatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeature(featureId: string, createFeatureRequest: CreateFeatureRequest, options?: RawAxiosRequestConfig): AxiosPromise<FeatureDetailsResponse> {
            return localVarFp.updateFeature(featureId, createFeatureRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update feature schedule by ID
         * @param {string} scheduleId 
         * @param {UpdateFeatureScheduleRequest} updateFeatureScheduleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeatureSchedule(scheduleId: string, updateFeatureScheduleRequest: UpdateFeatureScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<FeatureScheduleResponse> {
            return localVarFp.updateFeatureSchedule(scheduleId, updateFeatureScheduleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create or update LDAP configuration
         * @param {LDAPConfig} lDAPConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLDAPConfig(lDAPConfig: LDAPConfig, options?: RawAxiosRequestConfig): AxiosPromise<LDAPConfigResponse> {
            return localVarFp.updateLDAPConfig(lDAPConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the system license with a new license key
         * @summary Update license
         * @param {UpdateLicenseRequest} updateLicenseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLicense(updateLicenseRequest: UpdateLicenseRequest, options?: RawAxiosRequestConfig): AxiosPromise<LicenseStatusResponse> {
            return localVarFp.updateLicense(updateLicenseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update license acceptance status
         * @param {UpdateLicenseAcceptanceRequest} updateLicenseAcceptanceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLicenseAcceptance(updateLicenseAcceptanceRequest: UpdateLicenseAcceptanceRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateLicenseAcceptance(updateLicenseAcceptanceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update project name and description
         * @param {string} projectId 
         * @param {UpdateProjectRequest} updateProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject(projectId: string, updateProjectRequest: UpdateProjectRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectResponse> {
            return localVarFp.updateProject(projectId, updateProjectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update segment
         * @param {string} segmentId 
         * @param {UpdateSegmentRequest} updateSegmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSegment(segmentId: string, updateSegmentRequest: UpdateSegmentRequest, options?: RawAxiosRequestConfig): AxiosPromise<SegmentResponse> {
            return localVarFp.updateSegment(segmentId, updateSegmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Change my password
         * @param {ChangeUserPasswordRequest} changeUserPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userChangeMyPassword(changeUserPasswordRequest: ChangeUserPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.userChangeMyPassword(changeUserPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Verify 2FA-code on login
         * @param {TwoFAVerifyRequest} twoFAVerifyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verify2FA(twoFAVerifyRequest: TwoFAVerifyRequest, options?: RawAxiosRequestConfig): AxiosPromise<TwoFAVerifyResponse> {
            return localVarFp.verify2FA(twoFAVerifyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Add new project
     * @param {AddProjectRequest} addProjectRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addProject(addProjectRequest: AddProjectRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).addProject(addProjectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Archive a project
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public archiveProject(projectId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).archiveProject(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancel ongoing synchronization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cancelLDAPSync(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).cancelLDAPSync(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Approve enable 2FA (code from app)
     * @param {TwoFAConfirmRequest} twoFAConfirmRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public confirm2FA(twoFAConfirmRequest: TwoFAConfirmRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).confirm2FA(twoFAConfirmRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Finishes the SAML authentication flow.   The Identity Provider sends an HTTP-POST request that contains **SAMLResponse** (mandatory, Base64-encoded `<samlp:Response>` XML) and the optional **RelayState** parameter.   On success the service creates a user session (cookie or JWT) and redirects the browser to the application UI. 
     * @summary Assertion Consumer Service (ACS) endpoint
     * @param {string} sAMLResponse Base64-encoded IdP &#x60;&lt;samlp:Response&gt;&#x60; document
     * @param {string} relayState Value round-tripped from the initial authentication request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public consumeSAMLAssertion(sAMLResponse: string, relayState: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).consumeSAMLAssertion(sAMLResponse, relayState, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create flag variant for feature
     * @param {string} featureId 
     * @param {CreateFlagVariantRequest} createFlagVariantRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createFeatureFlagVariant(featureId: string, createFlagVariantRequest: CreateFlagVariantRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createFeatureFlagVariant(featureId, createFlagVariantRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create rule for feature
     * @param {string} featureId 
     * @param {CreateRuleRequest} createRuleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createFeatureRule(featureId: string, createRuleRequest: CreateRuleRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createFeatureRule(featureId, createRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create schedule for feature
     * @param {string} featureId 
     * @param {CreateFeatureScheduleRequest} createFeatureScheduleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createFeatureSchedule(featureId: string, createFeatureScheduleRequest: CreateFeatureScheduleRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createFeatureSchedule(featureId, createFeatureScheduleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create feature for project
     * @param {string} projectId 
     * @param {CreateFeatureRequest} createFeatureRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createProjectFeature(projectId: string, createFeatureRequest: CreateFeatureRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createProjectFeature(projectId, createFeatureRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create segment for project
     * @param {string} projectId 
     * @param {CreateSegmentRequest} createSegmentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createProjectSegment(projectId: string, createSegmentRequest: CreateSegmentRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createProjectSegment(projectId, createSegmentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create rule attribute
     * @param {CreateRuleAttributeRequest} createRuleAttributeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createRuleAttribute(createRuleAttributeRequest: CreateRuleAttributeRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createRuleAttribute(createRuleAttributeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new user (superuser only)
     * @param {CreateUserRequest} createUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createUser(createUserRequest: CreateUserRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createUser(createUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete feature
     * @param {string} featureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteFeature(featureId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteFeature(featureId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete feature schedule by ID
     * @param {string} scheduleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteFeatureSchedule(scheduleId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteFeatureSchedule(scheduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete LDAP configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteLDAPConfig(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteLDAPConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete rule attribute
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteRuleAttribute(name: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteRuleAttribute(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete segment
     * @param {string} segmentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteSegment(segmentId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteSegment(segmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a user (superuser only, cannot delete superusers)
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteUser(userId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Disable 2FA (using email-confirmation)
     * @param {TwoFADisableRequest} twoFADisableRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public disable2FA(twoFADisableRequest: TwoFADisableRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).disable2FA(twoFADisableRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request a password reset
     * @param {ForgotPasswordRequest} forgotPasswordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public forgotPassword(forgotPasswordRequest: ForgotPasswordRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).forgotPassword(forgotPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get current user information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCurrentUser(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get feature with rules and variants
     * @param {string} featureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFeature(featureId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getFeature(featureId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get feature schedule by ID
     * @param {string} scheduleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFeatureSchedule(scheduleId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getFeatureSchedule(scheduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get LDAP configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getLDAPConfig(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLDAPConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get LDAP statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getLDAPStatistics(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLDAPStatistics(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get synchronization log details
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getLDAPSyncLogDetails(id: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLDAPSyncLogDetails(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get synchronization logs
     * @param {number} [limit] 
     * @param {GetLDAPSyncLogsLevelEnum} [level] 
     * @param {string} [syncId] 
     * @param {string} [username] 
     * @param {string} [from] 
     * @param {string} [to] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getLDAPSyncLogs(limit?: number, level?: GetLDAPSyncLogsLevelEnum, syncId?: string, username?: string, from?: string, to?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLDAPSyncLogs(limit, level, syncId, username, from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get synchronization progress
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getLDAPSyncProgress(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLDAPSyncProgress(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get synchronization status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getLDAPSyncStatus(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLDAPSyncStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the current license status including validity, expiration date, and type
     * @summary Get license status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getLicenseStatus(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLicenseStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get product information including client ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getProductInfo(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getProductInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get project details
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getProject(projectId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getProject(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get SAML metadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSAMLMetadata(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSAMLMetadata(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get available SSO providers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSSOProviders(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSSOProviders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get segment by ID
     * @param {string} segmentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSegment(segmentId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSegment(segmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all feature schedules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listAllFeatureSchedules(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listAllFeatureSchedules(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List flag variants for feature
     * @param {string} featureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listFeatureFlagVariants(featureId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listFeatureFlagVariants(featureId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List rules for feature
     * @param {string} featureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listFeatureRules(featureId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listFeatureRules(featureId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List schedules for feature
     * @param {string} featureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listFeatureSchedules(featureId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listFeatureSchedules(featureId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List features for project
     * @param {string} projectId 
     * @param {ListProjectFeaturesKindEnum} [kind] Filter by feature kind
     * @param {boolean} [enabled] Filter by enabled state
     * @param {string} [textSelector] Case-insensitive text search across key, name, description, rollout_key
     * @param {ListProjectFeaturesSortByEnum} [sortBy] Sort by field
     * @param {SortOrder} [sortOrder] Sort order
     * @param {number} [page] Page number (starts from 1)
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listProjectFeatures(projectId: string, kind?: ListProjectFeaturesKindEnum, enabled?: boolean, textSelector?: string, sortBy?: ListProjectFeaturesSortByEnum, sortOrder?: SortOrder, page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listProjectFeatures(projectId, kind, enabled, textSelector, sortBy, sortOrder, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List segments for project
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listProjectSegments(projectId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listProjectSegments(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get projects list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listProjects(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listProjects(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List of rule attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listRuleAttributes(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listRuleAttributes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get desync feature IDs by segment ID
     * @param {string} segmentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listSegmentDesyncFeatureIDs(segmentId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listSegmentDesyncFeatureIDs(segmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all users (superuser only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listUsers(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Authenticate user and get access token
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).login(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refresh access token
     * @param {RefreshTokenRequest} refreshTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public refreshToken(refreshTokenRequest: RefreshTokenRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).refreshToken(refreshTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset/generate secret 2FA (using email-confirmation)
     * @param {TwoFAResetRequest} twoFAResetRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public reset2FA(twoFAResetRequest: TwoFAResetRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).reset2FA(twoFAResetRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset password using token
     * @param {ResetPasswordRequest} resetPasswordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public resetPassword(resetPasswordRequest: ResetPasswordRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).resetPassword(resetPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Handle SSO callback from Keycloak
     * @param {SSOCallbackRequest} sSOCallbackRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public sSOCallback(sSOCallbackRequest: SSOCallbackRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).sSOCallback(sSOCallbackRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Initiate SSO login flow
     * @param {string} provider Name of the SSO provider to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public sSOInitiate(provider: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).sSOInitiate(provider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set or unset superuser status (superuser only, cannot modify admin user)
     * @param {number} userId 
     * @param {SetSuperuserStatusRequest} setSuperuserStatusRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public setSuperuserStatus(userId: number, setSuperuserStatusRequest: SetSuperuserStatusRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).setSuperuserStatus(userId, setSuperuserStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set or unset user active status (superuser only)
     * @param {number} userId 
     * @param {SetUserActiveStatusRequest} setUserActiveStatusRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public setUserActiveStatus(userId: number, setUserActiveStatusRequest: SetUserActiveStatusRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).setUserActiveStatus(userId, setUserActiveStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Begin setup 2FA (generate secret and QR-code)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public setup2FA(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).setup2FA(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Synchronize customized feature rule
     * @param {string} featureId 
     * @param {string} ruleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public syncCustomizedFeatureRule(featureId: string, ruleId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).syncCustomizedFeatureRule(featureId, ruleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start user synchronization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public syncLDAPUsers(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).syncLDAPUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Test LDAP connection
     * @param {LDAPConnectionTest} lDAPConnectionTest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public testLDAPConnection(lDAPConnectionTest: LDAPConnectionTest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).testLDAPConnection(lDAPConnectionTest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Toggle feature enabled state
     * @param {string} featureId 
     * @param {ToggleFeatureRequest} toggleFeatureRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public toggleFeature(featureId: string, toggleFeatureRequest: ToggleFeatureRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).toggleFeature(featureId, toggleFeatureRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update feature with rules and variants
     * @param {string} featureId 
     * @param {CreateFeatureRequest} createFeatureRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateFeature(featureId: string, createFeatureRequest: CreateFeatureRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateFeature(featureId, createFeatureRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update feature schedule by ID
     * @param {string} scheduleId 
     * @param {UpdateFeatureScheduleRequest} updateFeatureScheduleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateFeatureSchedule(scheduleId: string, updateFeatureScheduleRequest: UpdateFeatureScheduleRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateFeatureSchedule(scheduleId, updateFeatureScheduleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create or update LDAP configuration
     * @param {LDAPConfig} lDAPConfig 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateLDAPConfig(lDAPConfig: LDAPConfig, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateLDAPConfig(lDAPConfig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the system license with a new license key
     * @summary Update license
     * @param {UpdateLicenseRequest} updateLicenseRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateLicense(updateLicenseRequest: UpdateLicenseRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateLicense(updateLicenseRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update license acceptance status
     * @param {UpdateLicenseAcceptanceRequest} updateLicenseAcceptanceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateLicenseAcceptance(updateLicenseAcceptanceRequest: UpdateLicenseAcceptanceRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateLicenseAcceptance(updateLicenseAcceptanceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update project name and description
     * @param {string} projectId 
     * @param {UpdateProjectRequest} updateProjectRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateProject(projectId: string, updateProjectRequest: UpdateProjectRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateProject(projectId, updateProjectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update segment
     * @param {string} segmentId 
     * @param {UpdateSegmentRequest} updateSegmentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateSegment(segmentId: string, updateSegmentRequest: UpdateSegmentRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateSegment(segmentId, updateSegmentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Change my password
     * @param {ChangeUserPasswordRequest} changeUserPasswordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public userChangeMyPassword(changeUserPasswordRequest: ChangeUserPasswordRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).userChangeMyPassword(changeUserPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Verify 2FA-code on login
     * @param {TwoFAVerifyRequest} twoFAVerifyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public verify2FA(twoFAVerifyRequest: TwoFAVerifyRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).verify2FA(twoFAVerifyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetLDAPSyncLogsLevelEnum = {
    Info: 'info',
    Warning: 'warning',
    Error: 'error'
} as const;
export type GetLDAPSyncLogsLevelEnum = typeof GetLDAPSyncLogsLevelEnum[keyof typeof GetLDAPSyncLogsLevelEnum];
export const ListProjectFeaturesKindEnum = {
    Simple: 'simple',
    Multivariant: 'multivariant'
} as const;
export type ListProjectFeaturesKindEnum = typeof ListProjectFeaturesKindEnum[keyof typeof ListProjectFeaturesKindEnum];
export const ListProjectFeaturesSortByEnum = {
    Name: 'name',
    Key: 'key',
    Enabled: 'enabled',
    Kind: 'kind',
    CreatedAt: 'created_at',
    UpdatedAt: 'updated_at'
} as const;
export type ListProjectFeaturesSortByEnum = typeof ListProjectFeaturesSortByEnum[keyof typeof ListProjectFeaturesSortByEnum];


/**
 * UsersApi - axios parameter creator
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Send 2FA email code for disable/reset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        send2FACode: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/me/2fa/send_code`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Send 2FA email code for disable/reset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async send2FACode(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.send2FACode(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.send2FACode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Send 2FA email code for disable/reset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        send2FACode(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.send2FACode(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Send 2FA email code for disable/reset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public send2FACode(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).send2FACode(options).then((request) => request(this.axios, this.basePath));
    }
}



